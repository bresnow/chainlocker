{"bresnow":{"\u001bcli":{"":{":":{"#":"bresnow/cli"},">":1658799252199.003}},"/cli":{"\u001b":{"r":{"e":{"adDirectorySync.mts":{"":{":":"import fs from 'fs'\nimport { join } from 'path'\n\nconst readDirectorySync = (directory: string, allFiles: string[]) => {\n  const files = fs.readdirSync(directory).map((file) => join(directory, file))\n  allFiles.push(...files)\n  files.forEach((file) => {\n    fs.statSync(file).isDirectory() && readDirectorySync(file, allFiles)\n  })\n  return allFiles\n}\n\nexport default readDirectorySync\n",">":1658799252198.013}},"gexes.mts":{"":{":":"export const EXPORT_DEFAULT_REGEX = new RegExp(/export default [a-zA-Z0-9]+/g)\nexport const JOYSTICK_UI_REGEX = new RegExp(/@joystick.js\\/ui/g)\nexport const OBJECT_REGEX = new RegExp(/{([^;]*)}/g)\n",">":1658799252198.017}}},"unner.mts":{"":{":":"import Gun, { IGunInstance, ISEAPair } from 'gun'\nimport { $, chalk, question, argv } from 'zx'\nimport { exists } from 'fsxx'\nimport { SysUserPair, getImmutableMachineInfo, MASTER_KEYS } from '../lib/auth.mjs'\nimport { err, warn } from '../lib/debug.mjs'\nimport Vault from './commands/vault.mjs'\nimport Help from '../lib/help.mjs'\nimport MappedCase from './commands/map-case.mjs'\n// import '../lib/chain-hooks/chainlocker.mjs'\nimport Push from '../lib/dev/push.mjs'\nimport Build from '../lib/dev/build.mjs'\nimport lzStr from 'lz-string'\n// import 'gun/lib/path.js'\n// import 'gun/lib/load.js'\n// import 'gun/lib/open.js'\n// import 'gun/lib/then.js'\nimport Store from './commands/store.mjs'\nimport config from '../../config/index.mjs'\nimport Pair from '../lib/encryption/pair.mjs'\nconst SEA = Gun.SEA\n\n//   let worked = (await SEA.work(vault, MASTER_KEYS)) as string\n//   let secureVault = lzStr.compressToUTF16(worked)\n//   let $LOCKER_PATH = config.lockerDirectory + '/' + secureVault\n//   let gun: IGunInstance<any>\n\n//   try {\n//     if (!exists($LOCKER_PATH)) {\n//       console.log(chalk.white.italic(`New vault setup. Creating ${vault}`))\n//       await $`mkdir -p ${$LOCKER_PATH}`\n//     } else {\n//       console.log(chalk.white.italic(`Opening ${vault}`))\n//     }\n\n//   } catch (error) {\n//     err(error as string)\n//   }\n// gun = new Gun({ file: `${$LOCKER_PATH}` })\n\n// gun.vault(vault)\n//   let chainlockerOpts = MappedCase(vault, gun)\n//   let cmd = await question(chalk.white(`Current Node ❱ ${chalk.red.bold('>>')}${path ?? 'root'}${chalk.red.bold('-->>')}  `))\n//   if (cmd) {\n//     cmd = cmd.trim()\n//     if (cmd) {\n//       let runner = cmd.split(' ').map((x) => x.trim().toLocaleLowerCase())\n//       let [command, opt, ...args] = runner\n//       // console.log(command, opt, args, '\\n', runner)\n\n//       if (chainlockerOpts.has(opt)) {\n//         let run = chainlockerOpts.get(opt)\n//         if (run) {\n//           await run(args)\n//         }\n//       } else {\n//         err(`${opt} is not a valid command.`)\n//         Help('chainlocker')\n//       }\n//     }\n//     if (command === ('exit' || 'quit')) {\n//       let confirm = await question(chalk.white(`Are you sure you want to exit? (y/N)`))\n//       if (confirm === 'y' && opt !== '--force') {\n//         console.log(chalk.white.italic(`Pushing to github before exit...`))\n//         await Push()\n//         process.exit(0)\n//       }\n//       if (confirm === 'y' && opt === '--force') {\n//         process.exit(0)\n//       }\n//       warn('Aborting exit.')\n//       await Run()\n//     }\n//   }\n// }\n",">":1658429297886.014}},"ainbowRoad.mts":{"":{":":"import { chalk } from 'zx'\n\nexport default () => {\n  return `${chalk.red('=')}${chalk.green('=')}${chalk.blue('=')}${chalk.red('=')}${chalk.green('=')}${chalk.blue('=')}`\n}\n",">":1658799252198.012}}},"index.mts":{"":{":":"#!/usr/bin/env node\nimport { question, chalk, $, sleep, fetch } from 'zx'\nimport { exists, read } from '../lib/file-utils.mjs'\nimport Gun, { ISEAPair } from 'gun'\nimport '../lib/chain-hooks/chainlocker.mjs'\nimport { findArg } from '../lib/arg.mjs'\nimport config from '../../config/index.mjs'\nimport { MASTER_KEYS } from '../lib/auth.mjs'\n\nimport { err } from '../lib/debug.mjs'\nimport lzString from 'lz-string'\nconst caret = chalk.green.bold('\\n❱ ')\nlet gun = Gun()\nconsole.clear()\n/**\n * Generates a Proof Od Work hash compressed into a url-safe URI string. Can use output as directory name or url paths without unsafe characters.\n * @param vaultname\n * @param keypair\n * @returns EncodedURIString\n */\nexport const getCID = async (vaultname: string, keypair: ISEAPair) =>\n  lzString.compressToEncodedURIComponent((await Gun.SEA.work(vaultname, keypair)) as string)\nexport const isDashedOption = (option: string) => option.startsWith('-')\nexport default async function Start(): Promise<void> {\n  console.log(`${caret}${chalk.blue.bold('Welcome to the ChainLocker CLI')}${caret}`)\n  let hasSalt = false\n  //argument finder\n  let [vault, vaultname] = findArg('vault', { dash: false })\n  if (!vault) {\n    vaultname = await question(chalk.white.bold(`Enter desired vault name${caret}`))\n  }\n  if (vaultname && typeof vaultname === 'string') {\n    let keypair = MASTER_KEYS,\n      cID: string\n    let [pair, salt] = findArg('pair', { dash: true })\n    if (pair) {\n      if (!salt) {\n        salt = await question(\n          chalk.white.bold(\n            `Enter a unique but ${chalk.bold.green(`memorable`)} string as a passphrase/salt for a new keypair \\n${chalk.yellowBright(\n              `WARNING: If you enter the wrong password then a new, empty vault will be created.`\n            )}${caret}`\n          )\n        )\n      }\n      if (salt) {\n        hasSalt = true\n      }\n    }\n    if (hasSalt && typeof salt === 'string') {\n      // salt is split into an array of strings separated by tabs and spaces\n      let pass = salt.split(/[\\t\\ ]/g)\n      keypair = await gun.keys(pass)\n    }\n    vaultname = vaultname.trim()\n    cID = await getCID(vaultname, keypair)\n    if (!exists(`${config.radDir}/${cID}`)) {\n      console.log(chalk.green(`Creating new vault ${vaultname} in 3 seconds...`))\n      console.log(\n        chalk.yellowBright(\n          `If you were trying to access an existing vault, you may need to exit ${chalk.white.italic(\n            `[CTRL-C]`\n          )} and re-enter your password.${caret}`\n        )\n      )\n      await sleep(3000)\n      try {\n        await $`mkdir -p ${config.radDir}/${cID}`\n      } catch (error) {\n        err(error)\n      }\n    }\n    gun = Gun({ file: `${config.radDir}/${cID}` })\n    //vault context returns an authenticated Gun user instance\n    let vault = gun.vault(\n      vaultname,\n      (_ack) => {\n        console.log(chalk.green(`Vault ${vaultname} Authorized. \\n public-key: ${keypair.pub} \\n`))\n      },\n      { keys: keypair }\n    )\n\n    // vault.on('in', (msg) => {\n    //   console.log(chalk.green(`Vault ${vaultname} In Message.`))\n    //   console.log(JSON.stringify(msg['#'], null, 2))\n    // })\n    gun.locker(['ChainLocker', `vault`, vaultname])\n\n    let [action, ...actioncmds] = findArg('store', { dash: false, valueIsArray: true })\n    let [actionf, ...actionOptsf] = findArg('fetch', { dash: false, valueIsArray: true })\n    if (actionf) {\n      action = 'fetch'\n      if (actionOptsf) {\n        actioncmds = actionOptsf\n      }\n    }\n    if (!action) {\n      async function storeFetchPrompt() {\n        action = await question(\n          chalk.white.bold(`Do you want to ${chalk.bold.green(`store`)} or ${chalk.bold.green(`fetch`)} data in ${vaultname}?${caret}`),\n          { choices: ['store', 'fetch'] }\n        )\n        if (action !== ('store' || 'fetch')) {\n          console.log(chalk.red(`${action} is not a valid option. Try again...`))\n          await storeFetchPrompt()\n        }\n        return action\n      }\n\n      action = await storeFetchPrompt()\n    }\n    if (action) {\n      let antwoord = await question(\n        chalk.white.bold(\n          `Input the path to desired locker (database node) \\nChainLocker node paths can be separated by \" \" ${chalk.bold.green(\n            `< space >`\n          )}, or \"\\\\t\" ${chalk.bold.green(`< tab >`)}${caret}`\n        )\n      )\n      actioncmds = antwoord.split(/[\\t\\ ]/g)\n    }\n    if (actioncmds.length > 0) {\n      let nodepath: string[] = []\n      let arrItr = actioncmds\n      let actionopts: [string, string][] = []\n      let iterator = arrItr.values()\n      for (const val of iterator) {\n        if (val) {\n          if (isDashedOption(val)) {\n            actionopts.push([val.replace(/-/g, '').trim(), iterator.next().value])\n          } else {\n            nodepath.push(val)\n          }\n        }\n      }\n\n      if (actionopts.length < 1) {\n        if (action === 'store') {\n          async function actionOptPrompt() {\n            let type = await question(\n              chalk.white.bold(\n                `Enter the ${chalk.bold.green(`type`)} of data you would like to store at path ${chalk.bold.green(\n                  nodepath.join(' ❱ ')\n                )}\\n Input ${chalk.bold.italic(\n                  `${chalk.italic.cyan(`stdin`)}, ${chalk.italic.cyan(`file`)}, or ${chalk.italic.cyan(`url`)}`\n                )}${caret}`\n              )\n            )\n            let value\n            switch (type) {\n              case 'stdin':\n                value = await question(\n                  chalk.white.bold(`Input string in stdin to store at path ${chalk.bold.green(nodepath.join(' ❱ '))}${caret}`)\n                )\n                break\n              case 'file':\n                value = await question(\n                  chalk.white.bold(`Input path to file to store at path ${chalk.bold.green(nodepath.join(' ❱ '))}${caret}`)\n                )\n                break\n              case 'url':\n                value = await question(chalk.white.bold(`Input url to store at path ${chalk.bold.white(nodepath.join(' ❱ '))}${caret}`))\n                break\n              default:\n                console.log(chalk.red(`${type} is not a valid option. Try again...`))\n                await actionOptPrompt()\n                break\n            }\n\n            return { action, type, value }\n          }\n\n          let results = await actionOptPrompt()\n          // console.log('OPT\\n   ', results)\n          let { type, value } = results\n          switch (type) {\n            case 'stdin':\n              gun.locker(nodepath).put({ type, value })\n\n              gun.locker(nodepath).value(function (value) {\n                console.log(chalk.green(`Stored at path ${nodepath.join(' ❱ ')}`))\n                console.log(value)\n                process.exit(0)\n              })\n              break\n            case 'file':\n              if (value) {\n                if (!exists(value)) {\n                  console.log(chalk.red(`File ${value} does not exist. Try again...`))\n                  await actionOptPrompt()\n                } else {\n                  value = await read(value)\n                  console.log(value)\n\n                  gun.locker(nodepath).put({ type, value })\n\n                  gun.locker(nodepath).value(function (value) {\n                    console.log(chalk.green(`Stored at path ${nodepath.join(' ❱ ')}`))\n                    console.log(value)\n                    process.exit(0)\n                  })\n                }\n              }\n              break\n            case 'url':\n              if (value) {\n                let _value = await fetch(value)\n                console.log (await _value.text())\n                value = await _value.text()\n                gun.locker(nodepath).put({ type, value })\n\n                gun.locker(nodepath).value(function (value) {\n                  console.log(chalk.green(`Stored at path ${nodepath.join(' ❱ ')}`))\n                  console.log(value)\n                  process.exit(0)\n                })\n              }\n              break\n            default:\n              console.log(chalk.red(`${type} is not a valid option. Try again...`))\n              await actionOptPrompt()\n\n\n          }\n        }\n      }\n      //\n      //         if (!_value) {\n      //           if (option === 'stdin') {\n      //             _value =\n      //           }\n      //           if (option === 'file') {\n\n      //           }\n      //           if (option === 'url') {\n      //             _value = await question(chalk.white.bold(`Input url to store at path ${chalk.bold.green(nodepath.join(' ❱'))}${caret}`))\n      //           }\n      //         }\n      //         actionopts.push([option, _value])\n\n      //   }\n      // }\n\n      // console.log(actionopts)\n\n      // if (actionopts.length >= 1) {\n      //   let path = nodepath.join('/')\n      //   console.log(nodepath, 'nodepath')\n      //   let locker = gun.locker(path)\n      //   for (const [option, value] of actionopts) {\n\n      //     if (option === 'stdin') {\n      //       locker.put({ data: value }, (ack) => {\n      //         console.log(ack)\n      //       })\n      //       locker.value((data) => {\n      //         console.log(data)\n      //       })\n      //     }\n      //     if (option === 'file') {\n      //       let file = await read(value)\n      //       locker.put({ data: file }, (ack) => {\n      //         console.log(ack)\n      //       })\n      //     }\n      //     if (option === 'url') {\n      //       let url = await fetch(value)\n      //       locker.put({ data: url }, (ack) => {\n      //         console.log(ack)\n      //       })\n      //     }\n      //   }\n    }\n  }\n}\nawait Start()\n//cleanup the nodepath\n\n//node path interface confirmation\n// console.log(chalk.green(`${vaultname} ❱❱❱--${nodepath.join('❱')}--❱❱`))\n// }\n// locker context\n// let locker = gun.locker(nodepath)\n// if (action === 'fetch') {\n//   locker.value((data) => {\n//     console.log(data)\n//   })\n// }\n\n// if (action === 'store') {\n//   let input\n\n//   let run = actions.get()\n//   if (run) {\n//     await run(input)\n//   }\n\n// }\n\n//     = await question(chalk.white.bold(`Build a node path for ${nameval}? \\n Type yes or no ❱ `), { choices: ['yes', 'no'] })\n// if (answer === 'yes') {\n//     let nodepath = await question(chalk.white.bold(`Enter desired path to ${nameval} \\n  ❱`))\n//     let lock = gun.locker(nodepath)\n//     lock.value(async (data) => {\n//         if (!data.err && data) {\n//             console.log('LOCKER VALUE\\n ', data)\n//         }\n//     })\n\n// }\n\n//         },\n//     ],\n// ])\n\n//     if (cmdMap.has(args[0])) {\n//         let run = cmdMap.get(args[0])\n//         let map = _.map((x) => x.toString())\n//         run && (await run(map, gun))\n//     }\n\n// console.log(args)\n// cmdMap.set('help', async function (_args: string[] = []) {\n//     Help('chainlocker')\n// }\n// )\n// let i=0, l=_.length\n// for (i; i<l; i++) {\n//     let cmd = _[i]\n\n// }\n// }\n",">":1658799252198.019}},"l":{"z-encrypt.mts":{"":{":":"import { ISEAPair } from 'gun'\nimport { lzObject } from 'lz-object'\nimport lzString from 'lz-string'\nimport { checkIfThis } from './check.mjs'\nimport { err, info } from './debug.mjs'\nimport Gun from 'gun'\n/**\n *\n * LZ-Encrypt uses the sea algorith to encrypt/decrypt and compress/decompresswith lz-string.\n * The methods only effect the object values as to easily traverse graph nodes\n */\n\ninterface CompressorToString {\n  (uncompressed: string): string\n}\ninterface CompressorToUintArray {\n  (uncompressed: string): Uint8Array\n}\ninterface DecompressorFromUintArray {\n  (compressed: Uint8Array): string | null\n}\ninterface DecompressorFromString {\n  (compressed: string): string | null\n}\nasync function encrypt(\n  object: any,\n  encryptionkey: ISEAPair | { epriv: string },\n  compressionOptions?: Partial<{ compress: boolean; encoding: 'utf16' | 'uint8array' | 'base64' | 'uri' }>\n) {\n  let compressionType = compressionOptions?.encoding ?? 'utf16'\n  let compress: CompressorToString | CompressorToUintArray\n  if (typeof object === 'string') {\n    let encrypted = await Gun.SEA.encrypt(object, encryptionkey)\n    switch (compressionType) {\n      case 'utf16':\n        compress = lzString.compressToUTF16\n        break\n      // case 'uint8array':\n      //   compress = lzString.compressToUint8Array\n      //   break\n      case 'base64':\n        compress = lzString.compressToBase64\n        break\n      case 'uri':\n        compress = lzString.compressToEncodedURIComponent\n        break\n      default:\n        err('Unknown compression type')\n        compress = lzString.compressToUTF16\n        break\n    }\n    let compressed = compress(encrypted)\n    return compressed\n  }\n\n  let obj: Record<string, any> = {}\n  if (object && checkIfThis.isObject(object)) {\n    const entries = Object.entries(object)\n    for (let i = 0; i < entries.length; i += 1) {\n      const [objectKey, objectValue] = entries[i]\n\n      if ((encryptionkey && checkIfThis.isString(objectValue)) || checkIfThis.isBoolean(objectValue) || checkIfThis.isNumber(objectValue)) {\n        try {\n          let encrypted = await Gun.SEA.encrypt(objectValue, encryptionkey)\n          Object.assign(obj, { [objectKey]: encrypted })\n        } catch (error) {\n          throw new Error(error as string)\n        }\n      }\n      if (encryptionkey && checkIfThis.isObject(objectValue)) {\n        await encrypt(objectValue, encryptionkey)\n      }\n    }\n    // console.log(JSON.stringify(lzObject.compress(obj, { output: 'uint8array'}), null, 2))\n    obj = lzObject.compress(obj, { output: compressionOptions?.encoding ?? 'utf16' })\n    return obj\n  }\n}\nasync function decrypt(\n  object: any,\n  encryptionkey: ISEAPair | { epriv: string },\n  compressionOptions?: Partial<{ compress: boolean; encoding: 'utf16' | 'uint8array' | 'base64' | 'uri' }>\n) {\n  if (!object) {\n    err('cannot decrypt and decompress object as it is undefined')\n    // throw new Error('cannot decrypt and decompress object as it is undefined');\n  }\n\n  let decompressionType = compressionOptions?.encoding ?? 'utf16'\n  if (typeof object === 'string') {\n    let decomp: string | null\n    let decrypted: any\n    switch (decompressionType) {\n      case 'utf16':\n        decomp = lzString.decompressFromUTF16(object)\n        decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n        break\n      // case 'uint8array':\n      //   decomp = lzString.decompressFromUint8Array(object)  as any as string\n      //   decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n      case 'base64':\n        decomp = lzString.decompressFromBase64(object)\n        decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n        break\n      case 'uri':\n        decomp = lzString.decompressFromEncodedURIComponent(object)\n        decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n        break\n      default:\n        err('Unknown compression type')\n        decomp = lzString.decompressFromUTF16(object)\n        decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n        break\n    }\n    return decrypted\n  }\n  object = lzObject.decompress(object, { output: compressionOptions?.encoding ?? 'utf16' })\n  let obj: Record<string, any> = {}\n  if (checkIfThis.isObject(object)) {\n    const entries: [string, string | any][] = Object.entries(object)\n    for (let i = 0; i < entries.length; i += 1) {\n      const [objectKey, objectValue] = entries[i]\n\n      if (encryptionkey && checkIfThis.isString(objectValue)) {\n        let decrypted = await Gun.SEA.decrypt(objectValue, encryptionkey)\n        Object.assign(obj, { [objectKey]: decrypted })\n      }\n      if (encryptionkey && checkIfThis.isObject(objectValue)) {\n        await decrypt(objectValue, encryptionkey)\n      }\n    }\n  }\n  return obj\n}\n\nexport default {\n  encrypt,\n  decrypt,\n}\n\n// const test = { test: 'njsanj1', test1: 'ajbsdkjasbda2', test11: 'dkjasbdksj3', test111: 'sadahsbdkshda', testyyyy: 'TESTERRRRR' },\n//   enc = { epriv: 'khjksbkdjbsajkbdljkasblfsbdajkfbsdkjfbasdklfbasljdbfskdjb' }\n// console.info(`encrypting test object`)\n// let encrypted = await encrypt(test, enc)\n// info(JSON.stringify(encrypted, null, 2))\n// console.info(`decrypting test object`)\n// let decrypted = await decrypt(encrypted, enc)\n// info(JSON.stringify(decrypted, null, 2))\n",">":1658799252198.016}},"ib":{"":{":":{"#":"bresnow/cli/lib"},">":1658799252199.003}},"o":{"ader.mts":{"":{":":"import { chalk } from 'zx'\nimport readline from 'readline'\n\nclass Loader {\n  message: any\n  frame: number\n  frames: string[]\n  freezeFrames: { stable: string; error: string }\n  interval: NodeJS.Timer | null | undefined\n  constructor(options: { defaultMessage: any; padding: any }) {\n    this.message = options.defaultMessage\n    this.frame = 0\n    this.frames = [\n      chalk.yellowBright((options.padding || '') + '>>-----'),\n      chalk.yellowBright((options.padding || '') + '->>----'),\n      chalk.yellowBright((options.padding || '') + '-->>---'),\n      chalk.yellowBright((options.padding || '') + '--->>--'),\n      chalk.yellowBright((options.padding || '') + '---->>-'),\n      chalk.yellowBright((options.padding || '') + '----->>'),\n      chalk.yellowBright((options.padding || '') + '----<<-'),\n      chalk.yellowBright((options.padding || '') + '---<<--'),\n      chalk.yellowBright((options.padding || '') + '--<<---'),\n      chalk.yellowBright((options.padding || '') + '-<<----'),\n      chalk.yellowBright((options.padding || '') + '<<-----'),\n    ]\n    this.freezeFrames = {\n      stable: chalk.yellowBright((options.padding || '') + '--->---'),\n      error: chalk.redBright((options.padding || '') + '!!!'),\n    }\n  }\n\n  getFrame() {\n    if (this.frame === this.frames.length - 1) {\n      this.frame = 0\n      return this.frame\n    }\n\n    this.frame += 1\n    return this.frame\n  }\n\n  start(message = '') {\n    if (message) {\n      this.message = message\n    }\n\n    this.interval = setInterval(() => {\n      const frameToRender = this.getFrame()\n      readline.cursorTo(process.stdout, 0)\n      process.stdout.write(`${this.frames[frameToRender]} ${this.message}`)\n    }, 80)\n  }\n\n  stop() {\n    clearInterval(this.interval ?? undefined)\n    readline.cursorTo(process.stdout, 0)\n    readline.clearLine(process.stdout, 1)\n    this.message = ''\n    this.interval = null\n  }\n\n  text(message = '') {\n    readline.clearLine(process.stdout, 1)\n\n    if (message) {\n      this.message = message\n    }\n\n    if (!this.interval) {\n      this.start()\n    }\n  }\n\n  pause(message = '', frame = 'stable') {\n    readline.clearLine(process.stdout, 1)\n\n    if (message) {\n      this.message = message\n    }\n\n    clearInterval(this.interval ?? undefined)\n    this.interval = null\n    const freezeFrame = frame === 'stable' ? this.freezeFrames[frame] : this.freezeFrames['error']\n    readline.cursorTo(process.stdout, 0)\n    process.stdout.write(`${freezeFrame ? `${freezeFrame} ` : ''}${this.message}`)\n  }\n\n  stable(message = '') {\n    this.pause(message)\n  }\n\n  error(message = '') {\n    this.pause(message, 'error')\n  }\n}\n\nexport default Loader\n",">":1658799252198.01}},"g.mts":{"":{":":"import { chalk } from 'zx'\nimport rainbowRoad from './rainbowRoad.mjs'\n\nexport default (\n  message: string,\n  options: { level: 'info' | 'success' | 'warning' | 'danger'; docs?: string; padding?: any; tools?: any[] }\n) => {\n  const colors = {\n    info: 'blue',\n    success: 'green',\n    warning: 'yellowBright',\n    danger: 'red',\n  }\n\n  const titles = {\n    info: '❱ Info',\n    success: '❱ Ok',\n    warning: '❱ Warning',\n    danger: '❱ Error',\n  }\n\n  const color = options.level ? colors[options.level] : 'gray'\n  const title = options.level ? titles[options.level] : 'Help'\n  const docs = options.docs || undefined\n\n  console.log(`\\n${options.padding || ''}${rainbowRoad()}\\n`)\n  //@ts-ignore\n  console.log(`${options.padding || ''}${chalk[color](`${title}:`)}\\n`)\n  console.log(`${options.padding || ''}${chalk.white(message)}\\n`)\n  console.log(`${options.padding || ''}${chalk.grey('---')}\\n`)\n  if (docs) {\n    console.log(`${options.padding || ''}${chalk.white('Relevant Documentation:')}\\n`)\n    console.log(`${options.padding || ''}${chalk.blue(docs)}\\n`)\n    console.log(`${options.padding || ''}${chalk.white('Stuck? Ask a Question:')}\\n`)\n  }\n  if (options.tools && Array.isArray(options.tools)) {\n    console.log(`${options.padding || ''}${chalk.white('Current comands:')}\\n`)\n    options.tools.forEach((tool: any) => {\n      console.log(`${options.padding || ''}${chalk.blue(`${tool.title} — ${tool.text}`)}\\n`)\n    })\n  }\n\n  console.log(`${options.padding || ''}${rainbowRoad()}\\n`)\n}\n",">":1658799252198.011}}}},"a":{"rg.mts":{"":{":":"/**\n * Argument filter/parser in a single line.\n * @param argValue what to find\n * @param slice  how many args to skip\n * @param opts dash: looking for a double dash?\n * @returns tuple of [arg, argValue]\n */\nexport const findArg = (argValue: string | RegExp, { slice = 2, dash = false, valueIsArray = false }) => {\n  let args = process.argv.slice(slice)\n  let i = 0,\n    l = args.length\n  for (i; i < l; i++) {\n    let arg = args[i]\n    let [_arg, ..._args] = [args[i], ...args.slice(i + 1)]\n    if (dash) {\n      if (arg === '--' + argValue) {\n        return !valueIsArray ? [arg, args[i + 1]] : [_arg, ..._args]\n      }\n    } else {\n      if (arg === argValue) {\n        return !valueIsArray ? [arg, args[i + 1]] : [_arg, ..._args]\n      }\n    }\n  }\n  return [null, ...args]\n}\n\n/**\n * Get the values of a previously parsed argument.\n */\nexport const findParsed = (\n  args: (string | null)[],\n  { dash = false, find, slice = 0 }: { dash?: boolean; find: string | RegExp; slice?: number }\n) => {\n  let i = 0,\n    l = args.length\n  for (i; i < l; i++) {\n    let arg = args[i]\n    if (dash) {\n      if (arg?.startsWith('--')) {\n        return [arg[i], arg[i + 1]]\n      }\n    } else {\n      if (arg === find) {\n        return [arg[i], arg[i + 1]]\n      }\n    }\n  }\n  return [null, null]\n}\n",">":1658799252198.004}},"uth.mts":{"":{":":"import { $, ProcessOutput } from 'zx'\nimport Pair from './encryption/pair.mjs'\nimport os from 'os'\nimport Gun from 'gun'\nlet sn: ProcessOutput\n$.verbose = false\n\nswitch (os.platform()) {\n  case 'win32':\n    sn = await $`wmic csproduct get`\n    break\n  case 'darwin':\n    sn = await $`system_profiler SPHardwareDataType | grep \"Serial\"`\n    // console.log(sn.stdout)\n    break\n  case 'linux':\n    if (os.arch() === 'arm') {\n      sn = await $`sudo cat /proc/cpuinfo | grep UUID`\n    } else {\n      sn = await $`sudo dmidecode -t system  | grep UUID`\n    }\n    break\n  case 'freebsd':\n    sn = await $`dmidecode -t system`\n    break\n}\n\nexport async function SysUserPair(secret?: string[]) {\n  let { username, serial, platform, arch } = getImmutableMachineInfo()\n  let salt = secret ? Object.values({ username, platform, arch }).concat(...secret) : Object.values({ username, platform, arch })\n  let keys = await Pair(serial, salt)\n  let hashedSerial = await Gun.SEA.work(serial, keys, null, { name: 'SHA-256', salt })\n  return { keys, username, serial: hashedSerial }\n}\nexport const { keys: MASTER_KEYS, serial: MASTER_SERIAL } = await SysUserPair()\nexport function getImmutableMachineInfo() {\n  let username = os.userInfo().username,\n    serial = sn.stdout.split(':')[1].trim(),\n    platform = os.platform(),\n    arch = os.arch()\n  return { username, serial, platform, arch }\n}\n",">":1658799252198.0051}}},"file-utils.mts":{"":{":":"import path from 'path'\nimport fs from 'fs-extra'\nimport fg from 'fast-glob'\nimport { $, cd } from 'zx'\nimport { join } from 'path'\n\nexport default async function FileUtils(readPath: string, writePath: string) {\n  if (!exists(readPath)) {\n    throw new Error(`file-utils: ${readPath} does not exist`)\n  }\n  if (!exists(writePath)) {\n    throw new Error(`file-utils: ${writePath} path does not exist`)\n  }\n  let file = {\n    async open(encoding: BufferEncoding = 'utf8') {\n      return await read(readPath, encoding)\n    },\n    async save(data: any) {\n      return await write(writePath, data)\n    },\n    change: {\n      async readFile(readPath: string) {\n        return await FileUtils(readPath, writePath)\n      },\n      async writeFile(writePath: string, data: any) {\n        return await (await FileUtils(readPath, writePath)).save(data)\n      },\n    },\n    JSON: await jsonRead(readPath),\n  }\n  return file\n}\n\nexport function interpretPath(...args: string[]) {\n  return path.join($.cwd || process.cwd(), ...(args ?? ''))\n}\n\nexport const readDirectorySync = (directory: string, allFiles: string[] = []) => {\n  const files = fs.readdirSync(directory).map((file) => join(directory, file))\n  allFiles.push(...files)\n  files.forEach((file) => {\n    fs.statSync(file).isDirectory() && readDirectorySync(file, allFiles)\n  })\n  return allFiles\n}\n\nexport function exists(path: string) {\n  path = interpretPath(path)\n  return fs.existsSync(path)\n}\n\nexport async function remove(path: string) {\n  path = interpretPath(path)\n  return fs.remove(interpretPath(path))\n}\n\nexport async function read(path: string, encoding?: BufferEncoding) {\n  path = interpretPath(path)\n  return fs.readFile(path, encoding ?? 'utf-8')\n}\n\nread.sync = function (...args: any) {\n  const path = interpretPath(args)\n  return fs.readFileSync(path, 'utf-8')\n}\n\nexport async function mkdir(...path: string[]) {\n  let input = interpretPath(...path)\n  return fs.mkdir(input)\n}\nexport async function write(path: any, content: any) {\n  return fs.writeFile(interpretPath(path), content, 'utf-8')\n}\n\nwrite.sync = function (path: any, content: string | NodeJS.ArrayBufferView) {\n  return fs.writeFileSync(interpretPath(path), content, 'utf-8')\n}\n\nasync function jsonRead(path: string) {\n  path = interpretPath(path)\n  return fs.readJSON(path)\n}\n\njsonRead.sync = function (path: string) {\n  path = interpretPath(path)\n  return fs.readJSONSync(path)\n}\n\nread.json = jsonRead\n\nexport function glob(args: string[]) {\n  const input = args.map((path) => interpretPath(path))\n  return fg(input, { cwd: interpretPath() })\n}\n\nexport { cd, fs, fg }\n",">":1658799252198.009}},"debug.mts":{"":{":":"import { chalk } from 'zx'\nimport rainbowRoad from './rainbowRoad.mjs'\n\nconst logger = (message: string, options: { level: 'info' | 'success' | 'warning' | 'danger'; title?: string }) => {\n  const colors = {\n    info: 'blue',\n    success: 'green',\n    warning: 'yellowBright',\n    danger: 'red',\n  }\n\n  const titles = {\n    info: '❱ Info',\n    success: '❱ Ok',\n    warning: '❱ Warning',\n    danger: '❱ Error',\n  }\n\n  const color = options.level ? colors[options.level] : 'gray'\n  const title = options.title ?? titles[options.level]\n\n  //@ts-ignore\n  console.log(`${''}${chalk[color](`${title}:`)}\\n`)\n  console.log(`${''}${chalk.white(message)}\\n`)\n  console.log(`${''}${chalk.grey('---')}\\n`)\n}\n\nexport function err(message: unknown) {\n  return logger(`${message}`, { level: 'danger' })\n}\n\nexport function warn(message: string) {\n  return logger(message, { level: 'warning' })\n}\n\nexport function info(message: string) {\n  return logger(message, { level: 'info' })\n}\n\nexport function success(message: string) {\n  return logger(message, { level: 'success' })\n}\n",">":1658799252198.007}},"check":{"IfValidJSON.mts":{"":{":":"export default (text = '') => {\n  try {\n    const json = JSON.parse(text)\n    return json\n  } catch (exception) {\n    return null\n  }\n}\n",">":1658799252198.006}},".mts":{"":{":":"export const checkIfThis = {\n  isObject: (value: any) => {\n    return !!(value && typeof value === 'object' && !Array.isArray(value))\n  },\n  isNumber: (value: any) => {\n    return !!isNaN(Number(value))\n  },\n  isBoolean: (value: any) => {\n    return value === 'true' || value === 'false' || value === true || value === false\n  },\n  isString: (value: any) => {\n    return typeof value === 'string'\n  },\n  isArray: (value: any) => {\n    return Array.isArray(value)\n  },\n}\n",">":1658799252198.018}}},"help.mts":{"":{":":"import { chalk, fs } from 'zx'\nimport rainbowRoad from './rainbowRoad.mjs'\n\nlet { version } = await fs.readJson('./package.json')\nexport default (which: 'chainlocker' | 'store' | 'all' = 'all') => {\n  console.log(`${''}${rainbowRoad()}`)\n  //@ts-ignore\n  console.log(`${''}${chalk.cyanBright.bold.underline('❱❱ ChainLocker ❱❱')} ${chalk.yellowBright.underline(' Alpha' + ` v${version} ❱❱`)}`)\n  console.log(`${''}${chalk.white('Distributed and Encrypted P2P Graph Database Protocol. ')}\\n`)\n  console.log(`${''}${rainbowRoad()}`)\n  // if (which == ('chainlocker' || 'all')) {\n  //   console.log(\n  //     `${chalk.cyan.bold('                  ')}${chalk.white(\n  //       `chainlocker  [   vault   ]  current (${chalk.italic('shows current vault context')})   `\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.white(\n  //       `                            --new (${chalk.italic('create new vault context')})   `\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.red(\n  //       `IN DEV                        --delete (${chalk.italic('delete current vault context')})   `\n  //     )}\\n`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.white(\n  //       `             [   keys    ]  --show (${chalk.italic('shows the keypair to current vault context')}) `\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.white(\n  //       `                            --generate (${chalk.italic('generate and name new keypair to store in current vault context')})   `\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.red(\n  //       `IN DEV                        --env (${chalk.italic('set keypair as environment variable')})   `\n  //     )}`\n  //   )\n  // }\n  // //TODO: PEER,  RELAY\n  // if (which == ('store' || 'all')) {\n  //   console.log(`\\n${chalk.cyan.bold('❱❱ DATABASE  ❱❱   ')}\\n`)\n  //   console.log(\n  //     `${chalk.blueBright('❱❱ Get Data  ❱❱  ')}${chalk.white(\n  //       '<--path/to/node/record-->  [   get   ]   --exec <node || shell || env || docker(IN DEV)> '\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                ')}${chalk.white(\n  //       '                                         --write-file <absolute local file path> '\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                ')}${chalk.white(\n  //       '                                         --write-file <absolute local file path> '\n  //     )}\\n`\n  //   )\n\n  //   console.log(\n  //     `${chalk.cyan.bold('❱❱ Put Data  ❱❱   ')}${chalk.white(\n  //       '<--path/to/node/record-->  [   put   ]   --file <absolute local file path> '\n  //     )}\\n`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                ')}${chalk.white('                                         --url <domain or ip addr> ')}`\n  //   )\n  //   console.log(`${chalk.blueBright('                ')}${chalk.white('                                         --string <stdin> ')}`)\n  // }\n  console.log(`\\n${''}${chalk.white('Chainlocker is superpowered by GUN. https://gun.eco ')}`)\n  console.log(`${''}${rainbowRoad()}`)\n  console.log(`${''}${rainbowRoad()}`)\n  console.log(`${''}${rainbowRoad()}`)\n}\n",">":1658799252198.008}},"src":{"":{":":{"#":"bresnow/cli/src"},">":1658429297887.003}}},"/":{"lib\u001b":{"scope.mts":{"":{":":"import Gun, { IGunInstance } from 'gun'\nimport 'gun/lib/path.js'\nimport chokidar from 'chokidar'\nimport fs from 'fs'\nimport { glob, chalk } from 'zx'\nimport fsUtil, { read, write, exists } from '../file-utils.mjs'\nimport os from 'os'\n\n/**\n * Scope watches the files in a directory and stores them in rad. No separate .ignore files as it uses the .gitignore file already in your current directory.\n * @param {string[]}what Glob pattern to watch\n * @param {callback(event, path, stats):void}callback Callback function to fire when a file or directory is added, changed, or removed\n * A fork of the HUB library... https://gun.eco/docs/hub.js#options\n * TODO: Broadcast files via relay server\n * TODO: ChainLocker\n */\nlet { username } = os.userInfo()\nGun.chain.scope = async function (what, callback, { verbose, alias }) {\n  let _gun = this\n  verbose = verbose ?? true\n  alias = alias ?? username\n  let matches = await glob(what, { gitignore: true })\n\n  try {\n    let scope = chokidar.watch(matches, { persistent: true })\n    const log = console.log\n    scope.on('all', (event, path, stats) => {\n      let fileOpts = { path, matches, event }\n      if (callback) {\n        callback(path, event, matches)\n        if (verbose) {\n          log(chalk.green(`scope callback fired : ${event} ${path}`))\n        }\n      }\n    })\n    scope\n      .on('add', async function (path, stats) {\n        if (!exists(path)) {\n          verbose && log(chalk.red(`File ${path} does not exist`))\n          return\n        }\n        let nodepath = path.includes('/') ? path.split('/').map((x) => x.trim()) : [path]\n        let name = nodepath.length > 1 ? nodepath.at(nodepath.length - 1) : nodepath[0]\n        nodepath.pop() && nodepath.pop()\n        if (nodepath && name) {\n          _gun\n            .get(alias)\n            .path(nodepath)\n            .put({ [name]: await read(path) })\n          verbose && log(chalk.green(`File ${path} has been added`))\n        } else {\n          log(chalk.red(`Error adding file ${path}`))\n          return\n        }\n      })\n      .on('change', async function (path, stats) {\n        if (!exists(path)) {\n          verbose && log(chalk.red(`File ${path} does not exist`))\n          return\n        }\n        let nodepath = path.includes('/') ? path.split('/').map((x) => x.trim()) : [path.trim()]\n        let name = nodepath.length > 1 ? nodepath.at(nodepath.length - 1) : nodepath[0]\n        nodepath.pop() && nodepath.pop()\n        if (nodepath && name) {\n          _gun\n            .get(alias)\n            .path(nodepath)\n            .put({ [name]: await read(path) })\n          verbose &&\n            _gun\n              .get(alias)\n              .path(nodepath)\n              .once((d) => {\n                log('PATH\\n' + chalk.green(d._['#']))\n              })\n          verbose && log(chalk.green(`File ${path} has been changed`))\n        } else {\n          log(chalk.red(`Error onChange for ${path}`))\n          return\n        }\n      })\n      .on('unlink', async function (path) {\n        if (!exists(path)) {\n          verbose && log(chalk.red(`File ${path} does not exist`))\n          return\n        }\n        let nodepath = path.includes('/') ? path.split('/').map((x) => x.trim()) : [path]\n        let name = nodepath.length > 1 ? nodepath.at(nodepath.length - 1) : nodepath[0]\n        nodepath.pop() && nodepath.pop()\n        if (nodepath && name) {\n          _gun\n            .get(alias)\n            .path([...nodepath, name])\n            .put(null as any)\n          verbose && log(chalk.green(`File ${path} has been removed`))\n        } else {\n          log(chalk.red(`Error deleting file ${path}`))\n          return\n        }\n      })\n    if (verbose) {\n      scope\n        ?.on('addDir', (path) => log(chalk.magenta(`Directory ${path} has been added`)))\n        .on('unlinkDir', (path) => log(chalk.magenta(`Directory ${path} has been removed`)))\n        .on('error', (error) => log(chalk.magenta(`Watcher error: ${error}`)))\n        .on('ready', () => log(chalk.magenta('Initial scan complete. Ready for changes')))\n    }\n  } catch (err) {\n    console.log(chalk.red('If you want to use the scope feature, you must install `chokidar` by typing `npm i chokidar` in your terminal.'))\n  }\n}\n",">":1658799252198.021}},"keys.mts":{"":{":":"import Gun from 'gun'\nimport { SysUserPair } from '../auth.mjs'\n",">":1658799252199}},"chainlocker.mts":{"":{":":"import Gun, { IGunChain } from 'gun'\nimport { SysUserPair, MASTER_KEYS } from '../auth.mjs'\nimport lz from '../lz-encrypt.mjs'\nimport 'gun/lib/path.js'\nimport 'gun/lib/load.js'\nimport 'gun/lib/open.js'\nimport 'gun/lib/then.js'\nimport config from '../../../config/index.mjs'\nimport { getCID } from '../../src/index.mjs'\nconst SEA = Gun.SEA\n\n//TODO: FIX UINT8Array decompression\n\nGun.chain.vault = function (vault, cback, opts) {\n  let _gun = this\n  let gun = _gun.user()\n  let keys = opts?.keys ?? MASTER_KEYS // can use the master key made from the machine serial or bring your own keys\n  gun = gun.auth(keys, (ack) => {\n    let err = (ack as any).err\n    if (err) {\n      throw new Error(err)\n    }\n    let lock = gun.get(`ChainLocker`)\n    lock.once(async function (data) {\n      let cID = await getCID(vault, keys)\n\n      if (!data) {\n        let _data = { vault, vault_id: cID, config: { rad_directory: config.radDir } }\n        // vault data for when peered with another locker or Gun graph\n        let encrypted = await lz.encrypt(_data, keys, { encoding: opts?.encoding ?? 'utf16' })\n        lock.put(encrypted, (ak: any) => {\n          if (ak.err) {\n            throw new Error(ak.err)\n          }\n        })\n      }\n      if (data) {\n        let obj, tmp\n        tmp = data._\n        delete data._\n        obj = await lz.decrypt(data, keys, { encoding: opts?.encoding ?? 'utf16' })\n        if (obj.vault && obj.vault_id !== cID) {\n          //check POW hashes to make sure they match\n          throw new Error(`Err authenticating ${vault}`)\n        }\n        cback && cback({ _: tmp, chainlocker: obj, gun: ack })\n      }\n    })\n  })\n\n  _gun.locker = (nodepath) => {\n    let path,\n      temp = gun as unknown as IGunChain<any> // gets tricky with types but doable\n    if (typeof nodepath === 'string') {\n      path = nodepath.split('/' || '.')\n      if (1 === path.length) {\n        temp = temp.get(nodepath)\n      }\n      nodepath = path\n    }\n    if (nodepath instanceof Array) {\n      if (nodepath.length > 1) {\n        var i = 0,\n          l = nodepath.length\n        for (i; i < l; i++) {\n          temp = temp.get(nodepath[i])\n        }\n      } else {\n        temp = temp.get(nodepath[0])\n      }\n    }\n    let node = temp\n    return {\n      async put(data, cb2) {\n        data = await lz.encrypt(data, keys, { encoding: opts?.encoding ?? 'utf16' })\n        node.put(data, (ack) => {\n          if (cb2) {\n            cb2(ack)\n          }\n        })\n      },\n      async value(cb) {\n        node.once(async (data) => {\n          let obj, tmp\n          if (!data) {\n            return cb({ err: 'Record not found' })\n          } else {\n            tmp = data._\n            delete data._\n            obj = await lz.decrypt(data, keys, { encoding: opts?.encoding ?? 'utf16' })\n            cb({ _: tmp, ...obj })\n          }\n        })\n      },\n    }\n  }\n\n  return gun //return gun user instance\n}\n\nGun.chain.keys = async function (secret) {\n  // can add secret string, username and password, or an array of secret strings\\\n  let keypair = MASTER_KEYS\n  if (secret) {\n    let sys = await SysUserPair(typeof secret === 'string' ? [secret] : [...secret])\n    keypair = sys.keys\n  }\n  return keypair\n}\n",">":1658799252198.02}},"build.mts":{"":{":":"#!/usr/bin/env node\nimport { glob } from 'zx'\nimport 'zx/globals'\nimport esbuild from 'esbuild'\nexport default async function () {\n  let matches = await glob(['**/*.mts', 'cli/**/*.mjs'], { gitignore: true })\n  matches.forEach((file) => {\n    console.log(file)\n    esbuild.build({\n      entryPoints: [file],\n      outfile: `bin/${file.replace('ts', 'js')}`,\n      bundle: false,\n      platform: 'node',\n    })\n  })\n}\n",">":1658799252199.001}},"p":{"air.mts":{"":{":":"let crypto = await import('crypto').then((WebCrypto) => {\n  return WebCrypto.webcrypto\n})\nimport forge from 'node-forge'\nimport EC from 'elliptic'\nimport btoa from 'btoa'\nimport { ISEAPair } from 'gun'\nconst ec = EC.ec\nexport interface IPair {\n  (pwd: any, salt: string | any[]): Promise<ISEAPair>\n}\nexport default async function Pair(pwd: any, salt: string | any[]): ReturnType<IPair> {\n  // forge.options.usePureJavaScript = true\n  return new Promise((resolve, reject) => {\n    let ec_p256 = new ec('p256')\n\n    if (!pwd) pwd = forge.random.getBytesSync(32)\n\n    let privateKey_d = forge.md.sha256.create().update('d').update(pwd) as any //decrypt key\n    let privateKey_s = forge.md.sha256.create().update('s').update(pwd) as any //sign key\n\n    if (salt) {\n      if (salt instanceof String) salt = [salt]\n\n      for (let i = 0; i < salt.length; i++) {\n        privateKey_s = privateKey_s.update(salt[i])\n        privateKey_d = privateKey_d.update(salt[i])\n      }\n    }\n\n    privateKey_s = privateKey_s.digest().toHex()\n    privateKey_d = privateKey_d.digest().toHex()\n\n    let keyA_d = ec_p256.keyFromPrivate(privateKey_d, 'hex')\n    let validation = keyA_d.validate()\n    if (validation.reason) return reject(validation.reason)\n\n    let keyA_s = ec_p256.keyFromPrivate(privateKey_s, 'hex')\n    validation = keyA_s.validate()\n    if (validation.reason) return reject(validation.reason)\n\n    resolve({\n      pub: keyBuffer_to_jwk('ECDSA', Buffer.from(keyA_s.getPublic('hex'), 'hex')) as string,\n      priv: arrayBufToBase64UrlEncode(Buffer.from(privateKey_s, 'hex')),\n      epub: keyBuffer_to_jwk('ECDH', Buffer.from(keyA_d.getPublic('hex'), 'hex')) as string,\n      epriv: arrayBufToBase64UrlEncode(Buffer.from(privateKey_d, 'hex')),\n      // secret: arrayBufToBase64UrlEncode(Buffer.from(keyA_d.derive(keyA_s.getPublic()).toString('hex'), 'hex'))\n    })\n  })\n\n  function arrayBufToBase64UrlEncode(buf: Iterable<number>) {\n    let binary = ''\n    let bytes = new Uint8Array(buf)\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i])\n    }\n    return btoa(binary).replace(/\\//g, '_').replace(/=/g, '').replace(/\\+/g, '-')\n  }\n\n  function keyBuffer_to_jwk(type: string, raw_publicKeyRawBuffer: Buffer) {\n    let key\n    switch (type) {\n      case 'ECDSA':\n      case 'ECDH':\n        if (raw_publicKeyRawBuffer[0] == 4)\n          key =\n            arrayBufToBase64UrlEncode(raw_publicKeyRawBuffer.slice(1, 33)) +\n            '.' +\n            arrayBufToBase64UrlEncode(raw_publicKeyRawBuffer.slice(33, 66))\n        break\n      default:\n        key = false\n        break\n    }\n    return key\n  }\n  //Hey dan whats this?\n  function b32(s: string) {\n    let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n\n    let parts = []\n    let quanta = Math.floor(s.length / 5)\n    let leftover = s.length % 5\n\n    if (leftover != 0) {\n      for (let i = 0; i < 5 - leftover; i++) {\n        s += '\\x00'\n      }\n      quanta += 1\n    }\n\n    for (let i = 0; i < quanta; i++) {\n      parts.push(alphabet.charAt(s.charCodeAt(i * 5) >> 3))\n      parts.push(alphabet.charAt(((s.charCodeAt(i * 5) & 0x07) << 2) | (s.charCodeAt(i * 5 + 1) >> 6)))\n      parts.push(alphabet.charAt((s.charCodeAt(i * 5 + 1) & 0x3f) >> 1))\n      parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 1) & 0x01) << 4) | (s.charCodeAt(i * 5 + 2) >> 4)))\n      parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 2) & 0x0f) << 1) | (s.charCodeAt(i * 5 + 3) >> 7)))\n      parts.push(alphabet.charAt((s.charCodeAt(i * 5 + 3) & 0x7f) >> 2))\n      parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 3) & 0x03) << 3) | (s.charCodeAt(i * 5 + 4) >> 5)))\n      parts.push(alphabet.charAt(s.charCodeAt(i * 5 + 4) & 0x1f))\n    }\n\n    let replace = 0\n    if (leftover == 1) replace = 6\n    else if (leftover == 2) replace = 4\n    else if (leftover == 3) replace = 3\n    else if (leftover == 4) replace = 1\n\n    for (let i = 0; i < replace; i++) parts.pop()\n    for (let i = 0; i < replace; i++) parts.push('=')\n\n    return parts.join('')\n  }\n}\n",">":1658799252199.003}},"ush.mts":{"":{":":"#!/usr/bin/env node\nimport { $, question, YAML, chalk } from 'zx'\nimport { io } from 'fsxx'\nimport 'zx/globals'\nexport default async function () {\n  $.verbose = false\n  let pkg = (await io.json`package.json`) as any\n  let message,\n    version = (pkg as any).version\n\n  // Version prompt ... (if not provided current version is used)\n  if (version === undefined) {\n    version = await question(`${chalk.green('Version? \\n Current Version ') + chalk.cyan(pkg.data.version)}: `)\n    version === '' ? (version = pkg.data.version) : (version = version.trim())\n  }\n  //PACKAGE>JSON MODIFY VERSION\n  pkg.data.version = version\n  await pkg.save()\n\n  //Commit Message (if not provided default message is used)\n  if (message === undefined) {\n    message = await question(chalk.green('Message for commit : '))\n    if (message === '' || message.length < 2) {\n      message = `Default Commit ${new Date(Date.now()).toLocaleString('en-US', { timeZone: 'America/New_York' }).slice(0, -3)}`\n    }\n  }\n\n  // Prettier and finalize\n\n  await $`git status`\n  try {\n    await $`yarn prettier`\n  } catch (error) {\n    console.log(chalk.red(error))\n  }\n  await $`git add --all`\n  await $`git commit -s -m ${`${message} | ${version}`}`\n  await $`git push`\n}\n",">":1658799252199.002}}}},"src\u001b":{"map-case.mts":{"":{":":"import Help from '../../lib/help.mjs'\n// import '../lib/chain-hooks/chainlocker.mjs'\nimport Push from '../../lib/dev/push.mjs'\nimport Build from '../../lib/dev/build.mjs'\nimport Vault from './vault.mjs'\nimport Store from './store.mjs'\nimport { IGunInstance } from 'gun'\nimport { err } from '../../lib/debug.mjs'\nexport default (vault: string, gun: IGunInstance) =>\n  new Map([\n    [\n      'help',\n      async function (_args: string[] = []) {\n        //TODO: finish help\n        Help('chainlocker')\n      },\n    ],\n    [\n      'vault',\n      async function (args: string[] = []) {\n        await Vault(args, vault, gun)\n      },\n    ],\n    [\n      'store',\n      async function (args: string[] = []) {\n        await Store(args, vault, gun)\n      },\n    ],\n    // DEVELOPER COMMANDS\n    [\n      'dev',\n      async function (args: string[] = []) {\n        let [key, value, ...flags] = args\n        if (key === 'push') {\n          console.log(chalk.white.italic(`Pushing to github...`))\n          try {\n            await Build()\n            await Push()\n          } catch (error) {\n            err(error as string)\n          }\n        }\n        if (key === 'build') {\n          console.log(chalk.white.italic(`Building...`))\n          await Build()\n        }\n      },\n    ],\n  ])\n",">":1658429297887.002}},"vault.mts":{"":{":":"import { chalk, $, fetch, glob, question } from 'zx'\nimport Help from '../../lib/help.mjs'\nimport config from '../../../config/index.mjs'\nimport { readDirectorySync } from '../../lib/file-utils.mjs'\nimport { remove } from '../../lib/file-utils.mjs'\nimport { warn } from '../../lib/debug.mjs'\nimport { IGunChain, IGunInstance } from 'gun'\nexport default async function (args: string[] = [], currentVault: string, gun: IGunChain<any> | IGunInstance<any>) {\n  let [key, value, ...flags] = args\n  //   console.log([key, value, ...flags], 'key value flags')\n  switch (key) {\n    case 'create':\n      let newVault = value\n      newVault = newVault.trim()\n      console.log(chalk.italic.white(`Checking out from ${currentVault} to ${newVault}\\n ❱ `))\n      break\n    case 'list':\n      let vdir = readDirectorySync(config.radDir)\n      console.log(vdir)\n      vdir.forEach(async (v) => {\n        if (!v) {\n          warn(\"No vaults found. Try the 'chainlocker create' command to create a new vault.\")\n        }\n        let [parent, goods] = v.split(config.radDir)\n        console.log(chalk.italic.blueBright(goods))\n      })\n      break\n    case 'delete':\n      //@ts-ignore\n      var peers = gun.back('opt.peers')\n      console.log('PEERS', peers)\n      //@ts-ignore\n      var mesh = gun.back('opt.mesh')\n      Object.values(peers).forEach(async (peer) => {\n        console.log(chalk.italic.white(`${peer}`))\n      })\n\n      console.log(`\\n`)\n      console.log(\n        chalk.bold.white(\n          `${currentVault} is connected to the peers listed above. You will be able to delete this vault locally but the encrypted data will remain on the network.`\n        )\n      )\n      let confirm = await question(\n        chalk.yellowBright.bold(`Please Input ${chalk.green.bold(currentVault.toUpperCase())} To Veryify This Choice.\\n`)\n      )\n      if (confirm.trim() === currentVault.toUpperCase()) {\n        console.log(chalk.italic.white(`Deleting ${currentVault}`))\n        await remove(config.radDir + currentVault)\n      } else {\n        warn('Aborting vault deletion.')\n      }\n\n      break\n    default:\n      Help()\n      break\n  }\n}\n",">":1658429297887.003}}}}}},"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo":{"\u001b":{"path":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path\"},\"~\":\"Sz9pwUfsrO0mtR9E8Q0paz/B1DHlzgd2uDsUzzXobPCMJViu9X3jEIVhuNfBHCZs7lN7BseHIwCz/4NH2oeAAg==\"}",">":1658430377292}},"ChainLocker":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/ChainLocker\"},\"~\":\"gGyW2w7TJyEop3SJ/VvKx6nkUSbV1jq7A/wormiC9mK6GoG1/s5qPvj/XstiY4ed/sljdvWor1GQProumGOsFg==\"}",">":1658797539127}},"testing":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/testing\"},\"~\":\"f9m/OzpmCyfo8pGGyJETA9v+MkwB20PqvRDlb4t8fbrNp8AJnq6r7cOl0S23ESTB9S3Jnbq8hYS0DrnT2DfUHg==\"}",">":1658798588935}}},"/":{"path":{"\u001bto":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to\"},\"~\":\"QG7WGHmwiAqmKLLVgVtMLaGQ+TngieKBIFVcavioAyj+Y8wodZQRylVg/qPHNM6Ea/D5dbOvrTE3NNYTyirt+g==\"}",">":1658430377292}},"/to":{"\u001b":{"node":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to/node\"},\"~\":\"jVynw/TTnFqL05U1AHq5YwL49tXjANJ9+G7h/KbpjjxUoSv+ANyuWPIe8sn8GhQDiwEW+jxrnUTpeKOnlBVyAA==\"}",">":1658430156430}},"my":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to/my\"},\"~\":\"K+L9xuEbLpSAFQC0lq0o7kN5sbLmifIqfP3US90+agOR7QKAtbJ25ig5WdCq8JytjOPVKX+lWkiCI51FrrYYSA==\"}",">":1658430377292}}},"/":{"node\u001bdata":{"":{":":"{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ഀ̡刧㠾䂋ìƄݐ࣠ᡬ䁶ŘƸ̔〱䂛ވ˶:䞠⎠ፓ༲繂ǴL‡崐ȸ¸ˑ䠥熊䀣⊠ঀ咪Ạʵޚ.晀äŜ侸Ψ拱䈀஀˯⟵⊸XĒܼᬠᶣ䀥᠀Ëâ倠彀  \",\"~\":\"LEaqt82lJKSeyWIgtrMfFadiOAjgO1I8TM8VwlCbJesxEeM5NSVTyPo/Q/+iXACRcIO6qNf7WzT6htIdEwnWfg==\"}",">":1658430156430}},"my":{"\u001bdata":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to/my/data\"},\"~\":\"4iWoUYntAK1fp9E91Z12TLpMAKTPsxU3NhmHhyOD/pHtNAnamcG1WVj/CPanjcw3/WHutJY++BG/VM3HKaCyyw==\"}",">":1658430377292}},"/data":{"\u001b":{"v2":{"":{":":"{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ༀ඼⁇ୀ᛫>〠〬捠㬠㕌Ψ&䁷*ìi嚀⌠ᢠហ⊠ጠᗐWv+mkࠠ橐㦲ఢ唐䎔䠧ဢᅀୀчⱄƠ⦩VGEcఠ幈-ਥ⍄䊥᧨Ŝ処.ㆠᡠʉဧ倣喔刀ᆆ*䡊,眭㫘Ȍ䩱ٚᒁػ沅%礠 \",\"~\":\"R4jKcsNP0eZXybB8np5w9ElN/W4J8ZQTjH4TCdZfoIK7NKsOMiyRRjFdZiLWTAvzWzSqkaLyirn4QxvRa6Psrg==\"}",">":1658430280142}},"node":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to/my/data/node\"},\"~\":\"0Pm1/Qh6+OZLPLlU2qMtL5Ggm3W8zENsfsFeBr9jKVTLuoQ3KtQH7N1gH78ut7UXPHPy4rCwbn4HessDHZ1yjg==\"}",">":1658430377292}}},"/node\u001bvalue":{"":{":":"{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ເܡ並倩䂖LTÈ΀Å䁯Æd˸ڱ䚠⤠渡త⠪兌ޠ௸=䁛传̦;ᙦbnᰠ更Řń瀡䖸θϸ˨新֔堯ℴ㷻䙸c㦠╶Ü⠠ഴ2槤䊠è䦌öᤠᗎ伸஀ҁ掘ļ䓆匠㢠Ǡ䐵à䙺淬楹㈠޺᛽䯬加̙  \",\"~\":\"Z1S2uhyqVTdx+L7jlQd8olH3VnCEYU5PwgoB5xptdqD6VMiTAZyh2cIcokZQqU2ohiT3RHhmARudBp8yy5BtTA==\"}",">":1658430377292}}}}}}},"ChainLocker\u001b":{"config":{"":{":":"{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ཌń°໦ϑ煠̠嬡☠䰦墰ዠጪ¬ƨ怤‣䁧r瑠䠤祐ʓ!〪兀ۅး‫榸ᑢ匲〠嘠㘠ḡⰡ⸴⩠͓ㆰƀܱ⚕&䔶䀻䤴㙬⤮〧,庠െೠī公Ď䌠✰䀹挦犡┘␠䨠ᕂ⣛ՀࣤⅨ㓀Þ† \",\"~\":\"BBv9dfXxPnAv6/r1MILfgWg5Zu1EKwxL77nHxeO3HIiUJs2w2zDfrM6hxvnRJ/BZ2NKke9eew0sc71nBwTfejQ==\"}",">":1658797539127}},"vault":{"":{":":"{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ɀ㢠瘡ᠳ⎡ᰣ࠮怫‣wl<Ǩ΄倵墡⬄ɰÀቧ䮠✠⋁5y~ᐠᩈ¶⑰ļĹ拐˸怦䤀°Ɔ噂4槓‷䀦䁙年᪴䈠㉜Ĕ/ⴠỼ䩠ї楠Ɯ䀠 \",\"~\":\"f7gxfdGOZGr88zUnlK3ja2022EX1fL7YXB6jXwzfZOvgEyo0WkL0ra2wfuTdaSpe7YYHsCFivC35rqBLTRRmag==\"}",">":1658797539127},"_id":{"":{":":"{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ഀ㢡渤堰斠ᐢࢀ๠ڠ晘〡〽䁂䀮¬ôƸ棩岔䠡Ⴠৠˇ$‾䀫‵›怽″憬䁕#䝐䁳ᬠ⭣ห䀡㷭◠ڱ瀡瀮〩ᑀ倾⇃⁋䊤禠Ⲡॣ․瀣〫瀠戠憇)䊸ରʷ慑冃䁄怵↢䉾怢斬᭙ᓠ㘠䵧³ᫀҀᒓ欢䊌ⴁसᴹᠠ૥側ᥑ楳ඤ䜸ጠⴥ+ダఠ氠的Fૠ䶸ơ励⮧烑癪g㸥ᙆ⬷†㌡椬Ĭᦐ子䖐慠Ƴ儞㵐䓡䇜Ⱐ䉧᤺;凬ጵຊ䊢⃌券☡␀␠Ỹ°Ԇీ〸㤖ඨᄥ縫ס炙璀ᐠǂ䃐ᡲԠ▜㴺棰桄ު䉠ぶᔬᰀ⑔䙫አ狠杈䆧Ԕ筆欶न炴%礠 \",\"~\":\"Wlq0YMpU5txiimCEzPwOQEFurcqgWhynXDjXg1XlHFp6VIIL2x7mQgpG49zZTcsEiYPMM1Y/+w+il26rHsl9fA==\"}",">":1658797539127}}}},"testing":{"\u001bone":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/testing/one\"},\"~\":\"Tu7DIB9KOAKDISsse8VNUQS+r3/4E+mymIbUNNMD+MELOnr8z5qYmM5Fvqs6dO6PxWYjWtyUMryCm4Dh9UNtBg==\"}",">":1658798588935}},"/one":{"\u001btwo":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/testing/one/two\"},\"~\":\"cbMOTJYLZ4RBw8HiQDUwuwTwKhVFqMkHEKOyr5QmwdxtaKKHG1kp3QKksWxG8QntQ5LlNCJArmev1zgs1CSzeg==\"}",">":1658798588935}},"/two":{"\u001bthree":{"":{":":"{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/testing/one/two/three\"},\"~\":\"bdwFrr8lR8kMWNITH3qaWlbAHfYp1/kj99sUKQ08O6AXhD2Wfaoc8UU4jT9/UuBJWJaPvPAZBMrZjRuBtd9aBg==\"}",">":1658798588935}},"/three\u001b":{"type":{"":{":":"{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈඀✠嘥⠩⁉âᰤ碠Ạ㒠夠瘣䐠砧ာ怣9²Ü†値Ꭰ຀௥&䔠ዠ෩ਣࠠ䔠ⴰ㡔Ƽżļ爡ఢ㓰ǉ䀡ࠣࠡ⦒䪭壄+%䱈s3ঠࣣአ̙  \",\"~\":\"9Kg/gKjbG+ONB9mWp3wynXkoU0Na6RDafb5RCOQKFQ1E6GeUZcRFWroCqrUzuMZvVv1qERWmjr0uFgQk5cE7yA==\"}",">":1658798588935}},"value":{"":{":":"{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ୀァ☢䠦怱ö¬̰ীዪ瀠Ⱐ⢀ᕥô㳨Ӈ䀦ᔠ氠乸堠㐢㣠X⠢ㆆ〮ု⚂倵毠ቮ․䮠ᶼᔲFड溘తͨə用ڐƵ瀡瀥煰ׅ⑐栣搡ೠ帬ḫ%•摖ק 满ठ➾乙䌌惡怡搠䋥ᣁİ妪䊢倣⪘呠咥ణᩑ‼怨倢妓㗅䖆㭝KЫ䀬昀˹挫Ԡ䍝㝩ॢ⑧䉹䂁䜄⻽⼭㌡ຯ深ሰ〣泘暥ढᶐⱰ姳଺⢊竨⒀╈⭓梀抦䕦ᕢᕐ℁Ĕ洩ɡℊ◅䛣ࣰ㵌摂Ⱔᠮڡ⢀漽䆶䤔ര䞃懨㐴ᵫ䁰㠨௣䑠廁Ⱒ⤌ᔦⷶ璶م䆢⢶9堧と㡾অᨴ湗ฤ⃤璆Ҡωヺ᦭悱橀౷劺㰬ᓬ梀㔺ᨡ挹䡀਩⎱ᑄᣐ冑檶ᣢ䴑ᙸㅹ䂐Č伦⋁䖆渣䨷婒ㅨݢ䵚䊿䄆ך㠫䚣磬ⰿ䳦瑴氷á䖸妠䷇ᘭ㜶ܱ䄊ℬڃ偨≑ⰴ疠⨴擁Ċ㴹ޠ搶傪Ȧ硠姅䃣䐼ᯇ⇄ᠤ㐪╔ᤄ怹౲䶪䚾ং燚䬦亣䤌悥ࢂᅢ亮݀ᆠػٌ᛬∽䊣à⹭扢偄¤値ۄಐ㞬䣸෢tΫᤄᢧ⇚ᔣჼ෠₎ᨧᆥᲣ㤌ⶉ熪㝦ᒶڠ瀼ᔣ䂶ᢤᆠद灠آ䆆ਭ炣ᴫ愪ᡮ咶ᜡ䦠ⳡ唐ᮦ$㞨▆↧傐ڣज̥䂂ڭა℧䆠■夤࠭傀Χᄪ㞡哲ᢦᒀ㒦慽ᰦ恼ᢦザ′ü❥䂴ᣬ㌄ثᠸよ〸ẩ桲᮪ऊҧ僰⫌⡕ᣤ剼ۨㄬ➢Õ఩桄㲶捜؍ᅌ㻃㦸¤⇧⑭梐Ϋ怸Ⳮ⃘᧢䥣↤偼ਥᦠڠ⇄ᳬ£ႧƸ㌧<࣠⅔崡䈋ಳቴ❢焜↣㡕ᢤ櫨ᾦ燄ᄣ(❬懱ᵥ⃥̧⤹ᠭ椨潡၈Ү◜ᔧㄪ̦₎ᣫ注㒠⇜ᦩ梴یpᤧザ↭寄ᦧĂっ᫤⦇拜嬥ᷚᱠ惈ᢣHᶤᄊᱦ䃠దᆆ௧〰䙭Άᢥ↸㞤堪䮡兢ئ/ħ䃆ᒢ´Ỳ傢ᘡ䂀勢䃤ધࢂ㒤夜ᄤᄜᵨ㆘てᣢ泫梉璯堪⺂童ኦ烨ᘤ∔㌦⃠ۈ⡕̯炂ḥ䁴஬⦠ᓮ㄀ᓥᦆ٫憚➭ᆆᓧ৙⁑⊴Ħۃ䜂僰࿤჈த․⳦䂐Ⰶ恄⡦烸㒠औᠩ槜ᣠ煼甲Ȟ墧෭儌ݹ燦Ⴆᑎ尧ひวₐؤშ੦懞潭ᄇᠤ⃦ႅ䂎І䂶㳨᧔ᔡ偠ᨢ崀Ả䅨ᨯ㥚ᨭ瀨ᬥ筚сၨࠨひႆᄄધ䀼᤮弐ԥ㳈બ⢣⼥ᤐᨤ兾㈶ᇌᝬH㌤೸ᘦ灊ځ䔠䁒῁䑀称Ģ悀䀰傦㛱ʠ␠䄌౳ᎡƸẠဪΐ⸣࣡4ᨢ䆚෠䠸愀థ瀱ᖸᮭ栬⃡䰴ᄬТ੒䌐٣㕮䁜笧傕฀ㄢ䕌෢ɖ䆀ᦣ吡J綨漟ⵁ䰮⇜஠䡜榐ᢦ瑉ᖸ漡倲෰䆥ƚಃȼΈㇶ栻䖸ऩ棜و焬ᣈᛐ䡐₄ႅԬRಣࡄàᨫ凄ៀ䠶0⚥㶍Űㆠ恘ؠᠰ㆚แ䑔䉍㚣䂏亩炆й娻凴ᜱ瑐䜇ዣ䩚Ӑ槃ࢶࢀ琶サ䳺㰸䇴ધ⎀ƨૌ਺౜瘭敯໡ἻЁᢣࡒԈ₷灎ਁ䢻ↁౡӇ䊔ᶣ汐ָㆧ抔ށ㕅⇙ɣ⊪Ƭ੢Ⲁ䆠溡♀šℨᢂᮒਸ䅠!兠ᔡ⑄ʠद怬و琳您ጅ䀸挐Ả汢䜈᢬Β倥愾◠Ϗ⍐ំ㸩ט⠠Þ† \",\"~\":\"MthGPVqZTW5rmKaA9qgYm62ICI4j/Lwmy5ZNK8B47qOlO6hqjtj3rx2AgFLsOIEsA3sUsVQxgvMdQH3jxpJEBA==\"}",">":1658798588935}}}}}}}},"l":{"61":{"h":{"emh90":{"1aOsyjkS5u6tl3\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658797841997}},"3tRds8tbC2yvVk\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658797841997.002}},"6n4LU43tzT0Wgk\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658797841997.004}}},"ic":{"nz01aOzJ5rxaU9cAK\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798015903}},"o00":{"1aI4LksRsyZhf8\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798015904}},"3tQz1VB5hhLu4y\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798015904.002}}}},"lxw":{"q0":{"1aVPAy26hW3WCX\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798183402}},"5zkyDybwTxV5p\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798183402.003}}},"s06nNkSZFSexiWxg\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798183404.004}}},"pso":{"90":{"1ajgkawc5ffoOC\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798363241}},"3tVw6lx5MC7554\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798363241.002}},"8pmKqdM9sMoIm\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798363241.0051}}},"a0":{"3tfXNUhKnupb4t\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798363242.002}},"96IrfSHtZqE6Dh\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798363242.006}},"bpF35qh6L1A95H\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798363242.008}}}},"t6":{"f":{"q":{"0":{"1acPb5BMvKvRUZ\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798521046}},"3tBqCmNFAEUXdl\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798521046.002}},"6nfExZRj6TgTt6\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798521046.004}},"vLaqQdTGFxuNT\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798521046.023}},"yIDOmCHR9OM0j\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798521046.0251}}},"10eSAPqQKfFKLfc\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798521046.027}}},"v0":{"1aKQ6tzGTHkQrT\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798521051}},"3tPmM4eI5hKsq5\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798521051.002}},"8OF7TC0Xl1gtv\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798521051.0051}}}},"g00":{"1aPc8cLqa06L7B\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798521056}},"5qHHJnl6Umw6R\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798521056.003}},"dz9IFkwUNC17m\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798521056.009}}}},"za":{"p":{"s01akh5VlO3iwHrG\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798806528}},"t":{"0":{"1aoW5D2MKgUe4c\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798806529}},"3tR6ZUNiNLw8Sy\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798806529.002}},"sh3rnKhvV6ixjn\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798806529.021}},"wlu90ln2QvnelK\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798806529.024}}},"1":{"1nCztZ8LFgbIwG\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798806529.028}},"pDp3fqtTDevrF\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798806529.0461}},"rm1tHNxxMh89MP\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798806529.048}},"yoP9K6DQbspoF\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798806529.053}}}},"u":{"0":{"gs72WzSapKEotT\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798806530.012}},"jmEkz32AJvZUBx\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798806530.014}},"mr80Lms7oEybo\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798806530.016}}},"1":{"emwSn7y29q0H1E\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798806530.038}},"hgV10VaZqBoxb\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798806530.04}},"p8QOZB4DoraJ6\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798806530.0461}}}},"z1":{"4720aUDy95kT75\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798806535.03}},"8y4b8JO9liFKu\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798806535.033}},"giZcDDTvU9C5m\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798806535.039}}}},"q":{"10":{"6nsgvO0FpeDe8p\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798806537.004}},"agHv1bVC0PwfsG\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798806537.007}},"e9gkad4HDbatEJ\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798806537.01}}},"31":{"auf6AWAx7n2BrC\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658798806539.0352}},"jpHv5LxATFvCZH\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658798806539.042}}},"408pQasqQu1WRIS\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658798806540.0051}}}}},"i":{"4n":{"p":{"p0":{"1a147BT1CuuCCN\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056653}},"3tjdktwFyEFesb\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056653.002}}},"q0":{"ooOPtKCzBDSH9r\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056654.018}},"r8wbGX35RRqEhR\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056654.02}}},"r0":{"1abpIjIo3GFnd7\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056655}},"3tJSq8xgHrd5Gx\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056655.002}}},"s":{"0":{"1aA13H7q5yfkiF\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056656}},"3tkz21LWmJPil4\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056656.002}},"6nKkHxLVnZm9yZ\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056656.004}},"agyzkypoxLxhpQ\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056656.007}},"lEGrPejfMMqTo\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056656.0151}},"nftO6ZTzXpW28F\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056656.017}}},"1":{"1nlrrgLdT8vs1N\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056656.028}},"47o6LESk9D44fq\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056656.03}},"9kuu4l2gdHxhJz\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056656.034}}},"2":{"3bd2HCyvPx4jW7\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056656.0571}},"5uF9iIm9lDR5Kw\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056656.059}}}},"t":{"0":{"1al5RIodbQopdd\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056657}},"sh4cJeWiGeaUiA\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056657.021}},"vwq7JXhrVUr8c\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056657.023}}},"13p03WOdvk2fvL\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056657.029}}}},"q":{"0":{"1":{"3LGjaemeZcki0\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056664.029}},"6q785s7HNGbeDz\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056664.032}}},"0trqyHygePPJ2zU\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056664.022}}},"3":{"0":{"bpllmKdTZ8FRny\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056667.008}},"e9mOOdjfIHhwAL\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056667.01}},"gswBf3C3ZjCVB4\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056667.012}}},"1":{"au1kWNeOsMer7C\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056667.0352}},"ddEQ4dNnaSjiIR\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056667.037}},"hgZpImwrD8d1S\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056667.04}}},"2":{"9n8CTd97orWvkQ\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056667.062}},"ch87bG0pqQwLhz\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056667.064}}}},"6":{"0":{"3tf4hKP46KOxvt\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056670.002}},"6npuuWqk4O2EHJ\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056670.004}},"96Kaavd5aVjCTB\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056670.006}}},"11nxHHxV3qFgT5h\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056670.028}}},"11":{"tuV2WvHVaiF4B\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056665.049}},"wo5tXjBGH8eNFU\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056665.052}}},"40":{"1au0E7ldJH23so\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056668}},"shA6q24nl7KBNl\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056668.021}},"v9wTGu1mEy3gC\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056668.023}}},"50":{"gsiGOPgqOkyTrA\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056669.012}},"m7RG6FoBzM2T2\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056669.016}},"ooXo0qcvB20HAo\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056669.018}},"wlX8umRJuvNv4v\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056669.024}}},"70":{"1aQK33SA3EK4Fi\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799056671}},"3tiVZAF7Rw6xIR\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799056671.002}}},"20fi49jpohHSUQIf\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799056666.011}}}},"8u":{"h":{"o":{"0":{"3tMlK1lFQU40K8\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252060.002}},"iWC6weTUE4OXR\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252060.013}},"trtFTGbmDZbcbL\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252060.022}},"wlywSEskrSx3nc\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252060.024}}},"Sf3s5sb3a1q1\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252059}}},"p01aFig5ruRP97DA\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252061}},"q0":{"96q6RevFAH0Pxd\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252062.006}},"dVJVgpclTdADk\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252062.009}},"mMXoDJBJNZZxV\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252062.016}}},"r":{"0":{"50HzOStHTmrvq\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252063.003}},"8qUjERsgLo6x0\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252063.0051}},"ag5eAND0oQmq9Z\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252063.007}}},"1":{"1nbXaVU6xrgIzC\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252063.028}},"6qtvGMZNe8TXfq\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252063.032}},"9kndj3pB0te61E\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252063.034}}},"2":{"3bhGcVEt5ot2io\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252063.0571}},"5uOSoomCGTuD9S\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252063.059}},"8dZ0zgkluoUoje\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252063.061}}}},"s":{"0":{"gshc87pBqjUyTu\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252064.012}},"jm2ICW07EI7Xm8\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252064.014}},"m4l7KbxvEpVHF\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252064.016}}},"1":{"aul55ePwUNoTal\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252064.0352}},"ddWTN05qqu3M92\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252064.037}},"h9xiVqc2DLMu5\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252064.04}}},"2":{"bWnFt854cViCq\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252064.063}},"fRDX8PbVsodUJ\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252064.0662}},"hkKpSphbtZdgJ4\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252064.068}}}},"t":{"0":{"shmiZrhsqBEHJJ\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252065.021}},"vU2UR8lkX26yM\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252065.023}}},"1":{"6qngkSorEJjpRG\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252065.032}},"ntxHGQwKCsG03L\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252065.0452}},"rmDZ5XHqJ0XET9\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252065.048}},"veGwjS76GeTQKK\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252065.051}}},"2ovCkcxN7rcx8g\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252065.073}}},"u":{"0":{"2j3MGlsmJugvmt\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252066.001}},"6nk5z2T1Zt6RNl\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252066.004}},"trp92BJe1DjO70\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252066.022}},"zD88iz7ejAxL9\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252066.0261}}},"1":{"5gcuWPAxtt5mRr\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252066.031}},"wolI7BAL03gAcK\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252066.052}}}},"v":{"0":{"2jFh3TBc8MRcL1\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252067.001}},"oozUujddH9dhOd\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252067.018}},"trmeAXII58wnDq\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252067.022}}},"1":{"5gCV93eMCmahxF\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252067.031}},"au5xsu87BICiya\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252067.0352}},"qcHWQGC3XydtSb\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252067.047}},"uBXmj6oy8QOPa\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252067.05}}}},"w":{"0":{"2jOnAQMIcpJTBE\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252068.001}},"qWH3rbfKnijGt\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252068.019}},"shf5KauX4xhpx4\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252068.021}},"v6jysdjjgTbTD\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252068.023}}},"1":{"nt9JbCR94wNrEw\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252068.0452}},"qcS1c0JAlBozIz\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252068.047}},"t3AFMDL0LE6zQ\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252068.049}}},"2":{"hkMggmeCsU7vGy\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252068.068}},"mmRDA7SsSU3ljI\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252068.072}}}},"x":{"0":{"3t2zA0rmwsIjry\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252069.002}},"r8JLggSSvGjQNn\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252069.02}},"vBnGjGZPGzR13\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252069.023}},"zZOjq5GiHc4yN\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252069.0261}}},"1":{"poVN2eBExyo1z\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252069.0461}},"rmNeI9TayjiqRe\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252069.048}},"wo877B5iIE2kVj\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252069.052}}}},"y":{"0":{"3teJ58g6i4hKcL\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252070.002}},"6n6MLfKD7JOFDL\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252070.004}},"fiR9T0qOzv19zn\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252070.011}}},"1":{"0eb3dOiWsU3XgU\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252070.027}},"3h1wTMRy2qb3A\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252070.029}},"5ga0jdBIZCLU2a\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252070.031}}}}},"i":{"b0":{"gs2BzlIrI7enUn\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252083.012}},"jmlcMTyJ4SZuA8\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252083.014}},"mL6ZjFXtUhiT0\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252083.016}}},"c":{"0":{"fixux9mNvGPXZk\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252084.011}},"jmWGLgt45ejnDi\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252084.014}},"nfV5DRde8IlA4Q\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252084.017}}},"1":{"emn1bfmcSqkxCf\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252084.038}},"hhUctzDoEwmWh\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252084.04}},"jpMS9WihahUn6l\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252084.042}}}},"d":{"0":{"6nveVSZCw8fbMf\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252085.004}},"aggJnXwVrekEjV\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252085.007}},"dArWsL0fzQ5Ba\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252085.009}}},"1":{"6qMlg274gFNaXN\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252085.032}},"9kSD4sJH9ZxO4w\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252085.034}},"cl1gE1hOD410d\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252085.0361}}},"2":{"3bWO0dpLNvsTeK\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252085.0571}},"5uuwfzrfDjGxtj\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252085.059}},"9nPaLQhRcxkzlT\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252085.062}}}},"e":{"0":{"iWpd4991cCehe\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252086.013}},"l25AHmI51M6yP\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252086.0151}},"oowjNg6FmijRLM\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252086.018}}},"1":{"gORj6kR6ha5kC\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252086.039}},"jpOT2td8wu6a8x\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252086.042}}}},"f01aL65ngHjd51f6\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252087}}},"li0":{"1aGKs2cZBMFdyN\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar'\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n      opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658799252198}},"3tR6LJ28mAQdRh\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658799252198.002}},"jmlOeFja1Lb2xN\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658799252198.014}}}}}},"5v":{"c":{"lp0":{"k01a25VFX7sEA0SG\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658426976740}},"l01aP09g1jphIp7a\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658426976741}},"n0e9VWl63qTjTRx8\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658426976743.01}}},"ng2":{"y01aEHDG2KnGJxk9\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658427058474}},"z0":{"1aTxOahOdyiL7m\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658427058475}},"6ncNpzKiyMloUj\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658427058475.004}}}}},"d":{"bb7":{"h01a5RhbCFhQftqy\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658428171901}},"i01aSPvRq5vSGLW3\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658428171902}},"j03tfh4rRS6KHjlu\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658428171903.002}}},"g3m":{"40":{"1a4hAXTefoc031\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658428395340}},"5cn9stz7ort6B\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658428395340.003}}},"301axx6Lvb5H9FKF\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658428395339}}},"h":{"azz0":{"1aJ7rpF5l9iCUy\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658428451567}},"3thrmG5AIbqKPn\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658428451567.002}}},"b0101aFUm3PvkKooq6\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658428451569}}},"j2se0":{"1aOHChIRrWZ8Ce\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658428534238}},"50pFAInpejdCO\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658428534238.003}},"agAb2Esk8T5IwH\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658428534238.007}}},"ssf":{"w0":{"1aekRBFJVVdMh9\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658428987388}},"3tjKHnPoylksTI\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658428987388.002}}},"x01arStmffkOhqf6\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658428987389}}},"yc5":{"g01ad9SNXWz7sfyi\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658429246212}},"h01aGuXZMT1kPvfl\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658429246213}},"j05chbRjJUod3K6\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658429246215.003}}},"zg0":{"t0":{"1aElppBcJ76FFV\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658429297885}},"5KeLNoybcAUtA\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658429297885.003}}},"u01a4R67XvQXXCAV\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658429297886}}}},"e":{"5bw":{"a":{"Uuzirih5O2r1\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658429572473}},"02j0EPFFX1i3oGN\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658429572474.001}}},"b01aMnzTbU1tUPVU\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658429572475}}},"6q3":{"h01a1x3hHpS24os6\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658429637533}},"i0":{"1aTiXpbtCubNWw\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658429637534}},"5qsFfKHOFOuoQ\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658429637534.003}}}},"ex4":{"8":{"03tZSpRnPjqCkgA\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658430019880.002}},"1ddsjgEEw7k9A81\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658430019880.037}}},"701aLtsWHuSrZZ7C\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658430019879}}},"g00":{"10":{"1aH488b8BJACNv\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658430070273}},"3txR7kLwDfT9nV\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658430070273.002}},"6nUqEKoFLJFBSR\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658430070273.004}}},"20":{"gsZHevGpWePE1J\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658430070274.012}},"jmPP495dAQ99Oj\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658430070274.014}},"mXplAeXP16LEv\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658430070274.016}}}},"h23":{"6":{"D9LKo5lsiApy\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658430119633.001}},"05pto7No2lmAVe\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658430119634.003}}},"805wQTF4gZaJGcU\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658430119636.003}}},"jq":{"kz0":{"1ai4AfUqeZIfaF\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658430244691}},"3tMNJqoAeRhZF1\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658430244691.002}}},"l001asf2B9I92obVt\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658430244692}}},"lql":{"d0":{"1aJt1OJkuMnF68\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658430338017}},"6niGEJWPAywACl\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658430338017.004}}},"f096ZRL5uxvLw904\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658430338019.006}}},"qv6":{"m0":{"1aRQ6tCQOZLRKX\u001bindex.mts":{"":{":":"import './cli/src/index.mjs'\n",">":1658430577246}},"870A1RBSJ7qS1\u001btypes.mts":{"":{":":"import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",">":1658430577246.0051}}},"n0gsO3sGyTlOAync\u001bindex.mts":{"":{":":"import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",">":1658430577247.012}}}}}}}