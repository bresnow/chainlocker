{
  "bresnow": {
    "\u001bcli": { "": { ":": { "#": "bresnow/cli" }, ">": 1658430577282 } },
    "/cli": {
      "\u001b": {
        "r": {
          "e": {
            "adDirectorySync.mts": {
              "": {
                ":": "import fs from 'fs'\nimport { join } from 'path'\n\nconst readDirectorySync = (directory: string, allFiles: string[]) => {\n  const files = fs.readdirSync(directory).map((file) => join(directory, file))\n  allFiles.push(...files)\n  files.forEach((file) => {\n    fs.statSync(file).isDirectory() && readDirectorySync(file, allFiles)\n  })\n  return allFiles\n}\n\nexport default readDirectorySync\n",
                ">": 1658430577247.006
              }
            },
            "gexes.mts": {
              "": {
                ":": "export const EXPORT_DEFAULT_REGEX = new RegExp(/export default [a-zA-Z0-9]+/g)\nexport const JOYSTICK_UI_REGEX = new RegExp(/@joystick.js\\/ui/g)\nexport const OBJECT_REGEX = new RegExp(/{([^;]*)}/g)\n",
                ">": 1658430577247.007
              }
            }
          },
          "unner.mts": {
            "": {
              ":": "import Gun, { IGunInstance, ISEAPair } from 'gun'\nimport { $, chalk, question, argv } from 'zx'\nimport { exists } from 'fsxx'\nimport { SysUserPair, getImmutableMachineInfo, MASTER_KEYS } from '../lib/auth.mjs'\nimport { err, warn } from '../lib/debug.mjs'\nimport Vault from './commands/vault.mjs'\nimport Help from '../lib/help.mjs'\nimport MappedCase from './commands/map-case.mjs'\n// import '../lib/chain-hooks/chainlocker.mjs'\nimport Push from '../lib/dev/push.mjs'\nimport Build from '../lib/dev/build.mjs'\nimport lzStr from 'lz-string'\n// import 'gun/lib/path.js'\n// import 'gun/lib/load.js'\n// import 'gun/lib/open.js'\n// import 'gun/lib/then.js'\nimport Store from './commands/store.mjs'\nimport config from '../../config/index.mjs'\nimport Pair from '../lib/encryption/pair.mjs'\nconst SEA = Gun.SEA\n\n//   let worked = (await SEA.work(vault, MASTER_KEYS)) as string\n//   let secureVault = lzStr.compressToUTF16(worked)\n//   let $LOCKER_PATH = config.lockerDirectory + '/' + secureVault\n//   let gun: IGunInstance<any>\n\n//   try {\n//     if (!exists($LOCKER_PATH)) {\n//       console.log(chalk.white.italic(`New vault setup. Creating ${vault}`))\n//       await $`mkdir -p ${$LOCKER_PATH}`\n//     } else {\n//       console.log(chalk.white.italic(`Opening ${vault}`))\n//     }\n\n//   } catch (error) {\n//     err(error as string)\n//   }\n// gun = new Gun({ file: `${$LOCKER_PATH}` })\n\n// gun.vault(vault)\n//   let chainlockerOpts = MappedCase(vault, gun)\n//   let cmd = await question(chalk.white(`Current Node ❱ ${chalk.red.bold('>>')}${path ?? 'root'}${chalk.red.bold('-->>')}  `))\n//   if (cmd) {\n//     cmd = cmd.trim()\n//     if (cmd) {\n//       let runner = cmd.split(' ').map((x) => x.trim().toLocaleLowerCase())\n//       let [command, opt, ...args] = runner\n//       // console.log(command, opt, args, '\\n', runner)\n\n//       if (chainlockerOpts.has(opt)) {\n//         let run = chainlockerOpts.get(opt)\n//         if (run) {\n//           await run(args)\n//         }\n//       } else {\n//         err(`${opt} is not a valid command.`)\n//         Help('chainlocker')\n//       }\n//     }\n//     if (command === ('exit' || 'quit')) {\n//       let confirm = await question(chalk.white(`Are you sure you want to exit? (y/N)`))\n//       if (confirm === 'y' && opt !== '--force') {\n//         console.log(chalk.white.italic(`Pushing to github before exit...`))\n//         await Push()\n//         process.exit(0)\n//       }\n//       if (confirm === 'y' && opt === '--force') {\n//         process.exit(0)\n//       }\n//       warn('Aborting exit.')\n//       await Run()\n//     }\n//   }\n// }\n",
              ">": 1658429297886.014
            }
          },
          "ainbowRoad.mts": {
            "": {
              ":": "import { chalk } from 'zx'\n\nexport default () => {\n  return `${chalk.red('=')}${chalk.green('=')}${chalk.blue('=')}${chalk.red('=')}${chalk.green('=')}${chalk.blue('=')}`\n}\n",
              ">": 1658430577247.0051
            }
          }
        },
        "index.mts": {
          "": {
            ":": "#!/usr/bin/env node\nimport { question, chalk, argv, sleep, $ } from 'zx'\nimport { exists, mkdir, read } from '../lib/file-utils.mjs'\nimport Gun, { ISEAPair } from 'gun'\nimport Help from '../lib/help.mjs'\nimport fs from 'fs-extra'\nimport '../lib/chain-hooks/chainlocker.mjs'\nimport { findArg, findParsed as filterParsedArgs, findParsed } from '../lib/arg.mjs'\nimport config from '../../config/index.mjs'\nimport { MASTER_KEYS } from '../lib/auth.mjs'\n\nimport { err, warn } from '../lib/debug.mjs'\nimport lzString from 'lz-string'\nconst caret = chalk.green.bold('\\n❱ ')\nlet gun = Gun()\n/**\n * Generates a Proof Od Work hash compressed into a url-safe URI string. Can use output as directory name or url paths without unsafe characters.\n * @param vaultname\n * @param keypair\n * @returns EncodedURIString\n */\nexport const getCID = async (vaultname: string, keypair: ISEAPair) =>\n  lzString.compressToEncodedURIComponent((await Gun.SEA.work(vaultname, keypair)) as string)\nexport const isDashedOption = (option: string) => option.startsWith('-')\nexport default async function (): Promise<void> {\nconsole.log(`${caret}${chalk.blue.bold('Welcome to the ChainLocker CLI')}${caret}`)\n  let hasSalt = false\n  //argument finder\n  let [vault, vaultname] = findArg('vault', { dash: false })\n  if (!vault) {\n    vaultname = await question(chalk.white.bold(`Enter desired vault name${caret}`))\n  }\n  if (vaultname && typeof vaultname === 'string') {\n    let keypair = MASTER_KEYS,\n      cID: string\n    let [pair, salt] = findArg('pair', { dash: true })\n    if (pair) {\n      if (!salt) {\n        salt = await question(\n          chalk.white.bold(\n            `Enter a unique but ${chalk.bold.green(`memorable`)} string as a passphrase/salt for a new keypair \\n${chalk.yellowBright(\n              `WARNING: If you enter the wrong password then a new, empty vault will be created.`\n            )}${caret}`\n          )\n        )\n      }\n      if (salt) {\n        hasSalt = true\n      }\n    }\n    if (hasSalt && typeof salt === 'string') {\n      // salt is split into an array of strings separated by tabs and spaces\n      let pass = salt.split(/[\\t\\ ]/g)\n      keypair = await gun.keys(pass)\n    }\n    vaultname = vaultname.trim()\n    cID = await getCID(vaultname, keypair)\n    if (!exists(`${config.radDir}/${cID}`)) {\n      console.log(chalk.green(`Creating new vault ${vaultname} in 3 seconds...`))\n      console.log(\n        chalk.yellowBright(\n          `If you were trying to access an existing vault, you may need to exit ${chalk.white.italic(\n            `[CTRL-C]`\n          )} and re-enter your password.${caret}`\n        )\n      )\n      try {\n        await $`mkdir -p ${config.radDir}/${cID}`\n      } catch (error) {\n        err(error)\n      }\n    }\n    gun = Gun({ file: `${config.radDir}/${cID}` })\n    //vault context returns an authenticated Gun user instance\n    let vault = gun.vault(\n      vaultname,\n      (ack) => {\n        console.log(chalk.green(`Vault ${vaultname} Authorized.`))\n        console.log(ack.ChainLocker)\n      },\n      { keys: keypair }\n    )\n\n    // vault.on('in', (msg) => {\n    //   console.log(chalk.green(`Vault ${vaultname} In Message.`))\n    //   console.log(JSON.stringify(msg['#'], null, 2))\n    // })\n    let locker = gun.locker(['ChainLocker', `vault`, vaultname])\n\n    let [action, ...actioncmds] = findArg('store', { dash: false, valueIsArray: true })\n    let [actionf, ...actionOptsf] = findArg('fetch', { dash: false, valueIsArray: true })\n    if (actionf) {\n      action = 'fetch'\n      if (actionOptsf) {\n        actioncmds = actionOptsf\n      }\n    }\n    if (!action) {\n      async function storeFetchPrompt() {\n        action = await question(\n          chalk.white.bold(`Do you want to ${chalk.bold.green(`store`)} or ${chalk.bold.green(`fetch`)} data in ${vaultname}?${caret}`),\n          { choices: ['store', 'fetch'] }\n        )\n        if (action !== ('store' || 'fetch')) {\n          console.log(chalk.red(`${action} is not a valid option. Try again...`))\n          await storeFetchPrompt()\n        }\n        return action\n      }\n\n      action = await storeFetchPrompt()\n    }\n    if (action) {\n      let antwoord = await question(\n        chalk.white.bold(\n          `Input the path to desired locker (database node) \\nChainLocker node paths can be separated by \" \" ${chalk.bold.green(\n            `< space >`\n          )}, or \"\\\\t\" ${chalk.bold.green(`< tab >`)}${caret}`\n        )\n      )\n      actioncmds = antwoord.split(/[\\t\\ ]/g)\n    }\n    if (actioncmds.length > 0) {\n      let nodepath: string[] = []\n      let arrItr = actioncmds\n      let actionopts: [string, string][] = []\n      let iterator = arrItr.values()\n      for (const val of iterator) {\n        if (val) {\n          if (isDashedOption(val)) {\n            actionopts.push([val.replace(/-/g, '').trim(), iterator.next().value])\n          } else {\n            nodepath.push(val)\n          }\n        }\n      }\n\n      if ( actionopts.length < 1) {\n        if (action === 'store'){\n        async function actionOptPrompt() {\n          let type = await question(\n            chalk.white.bold(\n              `Enter the ${chalk.bold.green(`type`)} of data you would like to store at path ${chalk.bold.green(\n                nodepath\n              )}\\n Input ${chalk.bold.italic(\n                `${chalk.italic.cyan(`stdin`)}, ${chalk.italic.cyan(`file`)}, or ${chalk.italic.cyan(`url`)}`\n              )}${caret}`\n            )\n          )\n          let value\n          switch (type) {\n            case 'stdin':\n              value = await question(\n                chalk.white.bold(`Input string in stdin to store at path ${chalk.bold.green(nodepath.join(' ❱ '))}${caret}`)\n              )\n              break\n            case 'file':\n              value = await question(\n                chalk.white.bold(`Input path to file to store at path ${chalk.bold.green(nodepath.join(' ❱ '))}${caret}`)\n              )\n              break\n            case 'url':\n              value = await question(\n                chalk.white.bold(`Input url to store at path ${chalk.bold.white(nodepath.join(' ❱ '))}${caret}`)\n              )\n              break\n            default:\n              console.log(chalk.red(`${type} is not a valid option. Try again...`))\n              await actionOptPrompt()\n              break\n          }\n\n          return {action, type,  value}\n        }\n\n        let results = await actionOptPrompt()\n        // console.log('OPT\\n   ', results)\nlet {type, value} = results\n        gun.locker(nodepath).put({type, value})\n        gun.locker(nodepath).value(function(value) {\n          console.log(chalk.green(`Stored at path ${nodepath.join(' ❱ ')}`))\n          console.log(value)\n        })\n\n      }\n        // process.exit(0)\n      }\n        //\n        //         if (!_value) {\n        //           if (option === 'stdin') {\n        //             _value =\n        //           }\n        //           if (option === 'file') {\n\n        //           }\n        //           if (option === 'url') {\n        //             _value = await question(chalk.white.bold(`Input url to store at path ${chalk.bold.green(nodepath.join(' ❱'))}${caret}`))\n        //           }\n        //         }\n        //         actionopts.push([option, _value])\n\n        //   }\n        // }\n\n        // console.log(actionopts)\n\n        // if (actionopts.length >= 1) {\n        //   let path = nodepath.join('/')\n        //   console.log(nodepath, 'nodepath')\n        //   let locker = gun.locker(path)\n        //   for (const [option, value] of actionopts) {\n\n        //     if (option === 'stdin') {\n        //       locker.put({ data: value }, (ack) => {\n        //         console.log(ack)\n        //       })\n        //       locker.value((data) => {\n        //         console.log(data)\n        //       })\n        //     }\n        //     if (option === 'file') {\n        //       let file = await read(value)\n        //       locker.put({ data: file }, (ack) => {\n        //         console.log(ack)\n        //       })\n        //     }\n        //     if (option === 'url') {\n        //       let url = await fetch(value)\n        //       locker.put({ data: url }, (ack) => {\n        //         console.log(ack)\n        //       })\n        //     }\n        //   }\n      }\n    }\n  }\n\n//cleanup the nodepath\n\n//node path interface confirmation\n// console.log(chalk.green(`${vaultname} ❱❱❱--${nodepath.join('❱')}--❱❱`))\n// }\n// locker context\n// let locker = gun.locker(nodepath)\n// if (action === 'fetch') {\n//   locker.value((data) => {\n//     console.log(data)\n//   })\n// }\n\n// if (action === 'store') {\n//   let input\n\n//   let run = actions.get()\n//   if (run) {\n//     await run(input)\n//   }\n\n// }\n\n\n//     = await question(chalk.white.bold(`Build a node path for ${nameval}? \\n Type yes or no ❱ `), { choices: ['yes', 'no'] })\n// if (answer === 'yes') {\n//     let nodepath = await question(chalk.white.bold(`Enter desired path to ${nameval} \\n  ❱`))\n//     let lock = gun.locker(nodepath)\n//     lock.value(async (data) => {\n//         if (!data.err && data) {\n//             console.log('LOCKER VALUE\\n ', data)\n//         }\n//     })\n\n// }\n\n//         },\n//     ],\n// ])\n\n//     if (cmdMap.has(args[0])) {\n//         let run = cmdMap.get(args[0])\n//         let map = _.map((x) => x.toString())\n//         run && (await run(map, gun))\n//     }\n\n// console.log(args)\n// cmdMap.set('help', async function (_args: string[] = []) {\n//     Help('chainlocker')\n// }\n// )\n// let i=0, l=_.length\n// for (i; i<l; i++) {\n//     let cmd = _[i]\n\n// }\n// }\n",
            ">": 1658430577247.008
          }
        },
        "l": {
          "z-encrypt.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\nimport { lzObject } from 'lz-object'\nimport lzString from 'lz-string'\nimport { checkIfThis } from './check.mjs'\nimport { err, info } from './debug.mjs'\nimport Gun from 'gun'\n/**\n *\n * LZ-Encrypt uses the sea algorith to encrypt/decrypt and compress/decompresswith lz-string.\n * The methods only effect the object values as to easily traverse graph nodes\n */\n\ninterface CompressorToString {\n  (uncompressed: string): string\n}\ninterface CompressorToUintArray {\n  (uncompressed: string): Uint8Array\n}\ninterface DecompressorFromUintArray {\n  (compressed: Uint8Array): string | null\n}\ninterface DecompressorFromString {\n  (compressed: string): string | null\n}\nasync function encrypt(\n  object: any,\n  encryptionkey: ISEAPair | { epriv: string },\n  compressionOptions?: Partial<{ compress: boolean; encoding: 'utf16' | 'uint8array' | 'base64' | 'uri' }>\n) {\n  let compressionType = compressionOptions?.encoding ?? 'utf16'\n  let compress: CompressorToString | CompressorToUintArray\n  if (typeof object === 'string') {\n    let encrypted = await Gun.SEA.encrypt(object, encryptionkey)\n    switch (compressionType) {\n      case 'utf16':\n        compress = lzString.compressToUTF16\n        break\n      // case 'uint8array':\n      //   compress = lzString.compressToUint8Array\n      //   break\n      case 'base64':\n        compress = lzString.compressToBase64\n        break\n      case 'uri':\n        compress = lzString.compressToEncodedURIComponent\n        break\n      default:\n        err('Unknown compression type')\n        compress = lzString.compressToUTF16\n        break\n    }\n    let compressed = compress(encrypted)\n    return compressed\n  }\n\n  let obj: Record<string, any> = {}\n  if (object && checkIfThis.isObject(object)) {\n    const entries = Object.entries(object)\n    for (let i = 0; i < entries.length; i += 1) {\n      const [objectKey, objectValue] = entries[i]\n\n      if ((encryptionkey && checkIfThis.isString(objectValue)) || checkIfThis.isBoolean(objectValue) || checkIfThis.isNumber(objectValue)) {\n        try {\n          let encrypted = await Gun.SEA.encrypt(objectValue, encryptionkey)\n          Object.assign(obj, { [objectKey]: encrypted })\n        } catch (error) {\n          throw new Error(error as string)\n        }\n      }\n      if (encryptionkey && checkIfThis.isObject(objectValue)) {\n        await encrypt(objectValue, encryptionkey)\n      }\n    }\n    // console.log(JSON.stringify(lzObject.compress(obj, { output: 'uint8array'}), null, 2))\n    obj = lzObject.compress(obj, { output: compressionOptions?.encoding ?? 'utf16' })\n    return obj\n  }\n}\nasync function decrypt(\n  object: any,\n  encryptionkey: ISEAPair | { epriv: string },\n  compressionOptions?: Partial<{ compress: boolean; encoding: 'utf16' | 'uint8array' | 'base64' | 'uri' }>\n) {\n  if (!object) {\n    err('cannot decrypt and decompress object as it is undefined')\n    // throw new Error('cannot decrypt and decompress object as it is undefined');\n  }\n\n  let decompressionType = compressionOptions?.encoding ?? 'utf16'\n  if (typeof object === 'string') {\n    let decomp: string | null\n    let decrypted: any\n    switch (decompressionType) {\n      case 'utf16':\n        decomp = lzString.decompressFromUTF16(object)\n        decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n        break\n      // case 'uint8array':\n      //   decomp = lzString.decompressFromUint8Array(object)  as any as string\n      //   decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n      case 'base64':\n        decomp = lzString.decompressFromBase64(object)\n        decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n        break\n      case 'uri':\n        decomp = lzString.decompressFromEncodedURIComponent(object)\n        decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n        break\n      default:\n        err('Unknown compression type')\n        decomp = lzString.decompressFromUTF16(object)\n        decrypted = decomp && Gun.SEA.decrypt(decomp, encryptionkey)\n        break\n    }\n    return decrypted\n  }\n  object = lzObject.decompress(object, { output: compressionOptions?.encoding ?? 'utf16' })\n  let obj: Record<string, any> = {}\n  if (checkIfThis.isObject(object)) {\n    const entries: [string, string | any][] = Object.entries(object)\n    for (let i = 0; i < entries.length; i += 1) {\n      const [objectKey, objectValue] = entries[i]\n\n      if (encryptionkey && checkIfThis.isString(objectValue)) {\n        let decrypted = await Gun.SEA.decrypt(objectValue, encryptionkey)\n        Object.assign(obj, { [objectKey]: decrypted })\n      }\n      if (encryptionkey && checkIfThis.isObject(objectValue)) {\n        await decrypt(objectValue, encryptionkey)\n      }\n    }\n  }\n  return obj\n}\n\nexport default {\n  encrypt,\n  decrypt,\n}\n\n// const test = { test: 'njsanj1', test1: 'ajbsdkjasbda2', test11: 'dkjasbdksj3', test111: 'sadahsbdkshda', testyyyy: 'TESTERRRRR' },\n//   enc = { epriv: 'khjksbkdjbsajkbdljkasblfsbdajkfbsdkjfbasdklfbasljdbfskdjb' }\n// console.info(`encrypting test object`)\n// let encrypted = await encrypt(test, enc)\n// info(JSON.stringify(encrypted, null, 2))\n// console.info(`decrypting test object`)\n// let decrypted = await decrypt(encrypted, enc)\n// info(JSON.stringify(decrypted, null, 2))\n",
              ">": 1658430577247.004
            }
          },
          "ib": { "": { ":": { "#": "bresnow/cli/lib" }, ">": 1658430577282 } },
          "o": {
            "ader.mts": {
              "": {
                ":": "import { chalk } from 'zx'\nimport readline from 'readline'\n\nclass Loader {\n  message: any\n  frame: number\n  frames: string[]\n  freezeFrames: { stable: string; error: string }\n  interval: NodeJS.Timer | null | undefined\n  constructor(options: { defaultMessage: any; padding: any }) {\n    this.message = options.defaultMessage\n    this.frame = 0\n    this.frames = [\n      chalk.yellowBright((options.padding || '') + '>>-----'),\n      chalk.yellowBright((options.padding || '') + '->>----'),\n      chalk.yellowBright((options.padding || '') + '-->>---'),\n      chalk.yellowBright((options.padding || '') + '--->>--'),\n      chalk.yellowBright((options.padding || '') + '---->>-'),\n      chalk.yellowBright((options.padding || '') + '----->>'),\n      chalk.yellowBright((options.padding || '') + '----<<-'),\n      chalk.yellowBright((options.padding || '') + '---<<--'),\n      chalk.yellowBright((options.padding || '') + '--<<---'),\n      chalk.yellowBright((options.padding || '') + '-<<----'),\n      chalk.yellowBright((options.padding || '') + '<<-----'),\n    ]\n    this.freezeFrames = {\n      stable: chalk.yellowBright((options.padding || '') + '--->---'),\n      error: chalk.redBright((options.padding || '') + '!!!'),\n    }\n  }\n\n  getFrame() {\n    if (this.frame === this.frames.length - 1) {\n      this.frame = 0\n      return this.frame\n    }\n\n    this.frame += 1\n    return this.frame\n  }\n\n  start(message = '') {\n    if (message) {\n      this.message = message\n    }\n\n    this.interval = setInterval(() => {\n      const frameToRender = this.getFrame()\n      readline.cursorTo(process.stdout, 0)\n      process.stdout.write(`${this.frames[frameToRender]} ${this.message}`)\n    }, 80)\n  }\n\n  stop() {\n    clearInterval(this.interval ?? undefined)\n    readline.cursorTo(process.stdout, 0)\n    readline.clearLine(process.stdout, 1)\n    this.message = ''\n    this.interval = null\n  }\n\n  text(message = '') {\n    readline.clearLine(process.stdout, 1)\n\n    if (message) {\n      this.message = message\n    }\n\n    if (!this.interval) {\n      this.start()\n    }\n  }\n\n  pause(message = '', frame = 'stable') {\n    readline.clearLine(process.stdout, 1)\n\n    if (message) {\n      this.message = message\n    }\n\n    clearInterval(this.interval ?? undefined)\n    this.interval = null\n    const freezeFrame = frame === 'stable' ? this.freezeFrames[frame] : this.freezeFrames['error']\n    readline.cursorTo(process.stdout, 0)\n    process.stdout.write(`${freezeFrame ? `${freezeFrame} ` : ''}${this.message}`)\n  }\n\n  stable(message = '') {\n    this.pause(message)\n  }\n\n  error(message = '') {\n    this.pause(message, 'error')\n  }\n}\n\nexport default Loader\n",
                ">": 1658430577247.002
              }
            },
            "g.mts": {
              "": {
                ":": "import { chalk } from 'zx'\nimport rainbowRoad from './rainbowRoad.mjs'\n\nexport default (\n  message: string,\n  options: { level: 'info' | 'success' | 'warning' | 'danger'; docs?: string; padding?: any; tools?: any[] }\n) => {\n  const colors = {\n    info: 'blue',\n    success: 'green',\n    warning: 'yellowBright',\n    danger: 'red',\n  }\n\n  const titles = {\n    info: '❱ Info',\n    success: '❱ Ok',\n    warning: '❱ Warning',\n    danger: '❱ Error',\n  }\n\n  const color = options.level ? colors[options.level] : 'gray'\n  const title = options.level ? titles[options.level] : 'Help'\n  const docs = options.docs || undefined\n\n  console.log(`\\n${options.padding || ''}${rainbowRoad()}\\n`)\n  //@ts-ignore\n  console.log(`${options.padding || ''}${chalk[color](`${title}:`)}\\n`)\n  console.log(`${options.padding || ''}${chalk.white(message)}\\n`)\n  console.log(`${options.padding || ''}${chalk.grey('---')}\\n`)\n  if (docs) {\n    console.log(`${options.padding || ''}${chalk.white('Relevant Documentation:')}\\n`)\n    console.log(`${options.padding || ''}${chalk.blue(docs)}\\n`)\n    console.log(`${options.padding || ''}${chalk.white('Stuck? Ask a Question:')}\\n`)\n  }\n  if (options.tools && Array.isArray(options.tools)) {\n    console.log(`${options.padding || ''}${chalk.white('Current comands:')}\\n`)\n    options.tools.forEach((tool: any) => {\n      console.log(`${options.padding || ''}${chalk.blue(`${tool.title} — ${tool.text}`)}\\n`)\n    })\n  }\n\n  console.log(`${options.padding || ''}${rainbowRoad()}\\n`)\n}\n",
                ">": 1658430577247.003
              }
            }
          }
        },
        "a": {
          "rg.mts": {
            "": {
              ":": "/**\n * Argument filter/parser in a single line.\n * @param argValue what to find\n * @param slice  how many args to skip\n * @param opts dash: looking for a double dash?\n * @returns tuple of [arg, argValue]\n */\nexport const findArg = (argValue: string | RegExp, { slice = 2, dash = false, valueIsArray = false }) => {\n  let args = process.argv.slice(slice)\n  let i = 0,\n    l = args.length\n  for (i; i < l; i++) {\n    let arg = args[i]\n    let [_arg, ..._args] = [args[i], ...args.slice(i + 1)]\n    if (dash) {\n      if (arg === '--' + argValue) {\n        return !valueIsArray ? [arg, args[i + 1]] : [_arg, ..._args]\n      }\n    } else {\n      if (arg === argValue) {\n        return !valueIsArray ? [arg, args[i + 1]] : [_arg, ..._args]\n      }\n    }\n  }\n  return [null, ...args]\n}\n\n/**\n * Get the values of a previously parsed argument.\n */\nexport const findParsed = (\n  args: (string | null)[],\n  { dash = false, find, slice = 0 }: { dash?: boolean; find: string | RegExp; slice?: number }\n) => {\n  let i = 0,\n    l = args.length\n  for (i; i < l; i++) {\n    let arg = args[i]\n    if (dash) {\n      if (arg?.startsWith('--')) {\n        return [arg[i], arg[i + 1]]\n      }\n    } else {\n      if (arg === find) {\n        return [arg[i], arg[i + 1]]\n      }\n    }\n  }\n  return [null, null]\n}\n",
              ">": 1658430577246.002
            }
          },
          "uth.mts": {
            "": {
              ":": "import { $, ProcessOutput } from 'zx'\nimport Pair from './encryption/pair.mjs'\nimport os from 'os'\nimport Gun from 'gun'\nlet sn: ProcessOutput\n$.verbose = false\n\nswitch (os.platform()) {\n  case 'win32':\n    sn = await $`wmic csproduct get`\n    break\n  case 'darwin':\n    sn = await $`system_profiler SPHardwareDataType | grep \"Serial\"`\n    // console.log(sn.stdout)\n    break\n  case 'linux':\n    if (os.arch() === 'arm') {\n      sn = await $`sudo cat /proc/cpuinfo | grep UUID`\n    } else {\n      sn = await $`sudo dmidecode -t system  | grep UUID`\n    }\n    break\n  case 'freebsd':\n    sn = await $`dmidecode -t system`\n    break\n}\n\nexport async function SysUserPair(secret?: string[]) {\n  let { username, serial, platform, arch } = getImmutableMachineInfo()\n  let salt = secret ? Object.values({ username, platform, arch }).concat(...secret) : Object.values({ username, platform, arch })\n  let keys = await Pair(serial, salt)\n  let hashedSerial = await Gun.SEA.work(serial, keys, null, { name: 'SHA-256', salt })\n  return { keys, username, serial: hashedSerial }\n}\nexport const { keys: MASTER_KEYS, serial: MASTER_SERIAL } = await SysUserPair()\nexport function getImmutableMachineInfo() {\n  let username = os.userInfo().username,\n    serial = sn.stdout.split(':')[1].trim(),\n    platform = os.platform(),\n    arch = os.arch()\n  return { username, serial, platform, arch }\n}\n",
              ">": 1658430577246.003
            }
          }
        },
        "file-utils.mts": {
          "": {
            ":": "import path from 'path'\nimport fs from 'fs-extra'\nimport fg from 'fast-glob'\nimport { $, cd } from 'zx'\nimport { join } from 'path'\n\nexport default async function FileUtils(readPath: string, writePath: string) {\n  if (!exists(readPath)) {\n    throw new Error(`file-utils: ${readPath} does not exist`)\n  }\n  if (!exists(writePath)) {\n    throw new Error(`file-utils: ${writePath} path does not exist`)\n  }\n  let file = {\n    async open(encoding: BufferEncoding = 'utf8') {\n      return await read(readPath, encoding)\n    },\n    async save(data: any) {\n      return await write(writePath, data)\n    },\n    change: {\n      async readFile(readPath: string) {\n        return await FileUtils(readPath, writePath)\n      },\n      async writeFile(writePath: string, data: any) {\n        return await (await FileUtils(readPath, writePath)).save(data)\n      },\n    },\n    JSON: await jsonRead(readPath),\n  }\n  return file\n}\n\nexport function interpretPath(...args: string[]) {\n  return path.join($.cwd || process.cwd(), ...(args ?? ''))\n}\n\nexport const readDirectorySync = (directory: string, allFiles: string[] = []) => {\n  const files = fs.readdirSync(directory).map((file) => join(directory, file))\n  allFiles.push(...files)\n  files.forEach((file) => {\n    fs.statSync(file).isDirectory() && readDirectorySync(file, allFiles)\n  })\n  return allFiles\n}\n\nexport function exists(path: string) {\n  path = interpretPath(path)\n  return fs.existsSync(path)\n}\n\nexport async function remove(path: string) {\n  path = interpretPath(path)\n  return fs.remove(interpretPath(path))\n}\n\nexport async function read(path: string, encoding?: BufferEncoding) {\n  path = interpretPath(path)\n  return fs.readFile(path, encoding ?? 'utf-8')\n}\n\nread.sync = function (...args: any) {\n  const path = interpretPath(args)\n  return fs.readFileSync(path, 'utf-8')\n}\n\nexport async function mkdir(...path: string[]) {\n  let input = interpretPath(...path)\n  return fs.mkdir(input)\n}\nexport async function write(path: any, content: any) {\n  return fs.writeFile(interpretPath(path), content, 'utf-8')\n}\n\nwrite.sync = function (path: any, content: string | NodeJS.ArrayBufferView) {\n  return fs.writeFileSync(interpretPath(path), content, 'utf-8')\n}\n\nasync function jsonRead(path: string) {\n  path = interpretPath(path)\n  return fs.readJSON(path)\n}\n\njsonRead.sync = function (path: string) {\n  path = interpretPath(path)\n  return fs.readJSONSync(path)\n}\n\nread.json = jsonRead\n\nexport function glob(args: string[]) {\n  const input = args.map((path) => interpretPath(path))\n  return fg(input, { cwd: interpretPath() })\n}\n\nexport { cd, fs, fg }\n",
            ">": 1658430577247.001
          }
        },
        "debug.mts": {
          "": {
            ":": "import { chalk } from 'zx'\nimport rainbowRoad from './rainbowRoad.mjs'\n\nconst logger = (message: string, options: { level: 'info' | 'success' | 'warning' | 'danger'; title?: string }) => {\n  const colors = {\n    info: 'blue',\n    success: 'green',\n    warning: 'yellowBright',\n    danger: 'red',\n  }\n\n  const titles = {\n    info: '❱ Info',\n    success: '❱ Ok',\n    warning: '❱ Warning',\n    danger: '❱ Error',\n  }\n\n  const color = options.level ? colors[options.level] : 'gray'\n  const title = options.title ?? titles[options.level]\n\n  //@ts-ignore\n  console.log(`${''}${chalk[color](`${title}:`)}\\n`)\n  console.log(`${''}${chalk.white(message)}\\n`)\n  console.log(`${''}${chalk.grey('---')}\\n`)\n}\n\nexport function err(message: unknown) {\n  return logger(`${message}`, { level: 'danger' })\n}\n\nexport function warn(message: string) {\n  return logger(message, { level: 'warning' })\n}\n\nexport function info(message: string) {\n  return logger(message, { level: 'info' })\n}\n\nexport function success(message: string) {\n  return logger(message, { level: 'success' })\n}\n",
            ">": 1658430577246.004
          }
        },
        "check": {
          "IfValidJSON.mts": {
            "": {
              ":": "export default (text = '') => {\n  try {\n    const json = JSON.parse(text)\n    return json\n  } catch (exception) {\n    return null\n  }\n}\n",
              ">": 1658430577247.0151
            }
          },
          ".mts": {
            "": {
              ":": "export const checkIfThis = {\n  isObject: (value: any) => {\n    return !!(value && typeof value === 'object' && !Array.isArray(value))\n  },\n  isNumber: (value: any) => {\n    return !!isNaN(Number(value))\n  },\n  isBoolean: (value: any) => {\n    return value === 'true' || value === 'false' || value === true || value === false\n  },\n  isString: (value: any) => {\n    return typeof value === 'string'\n  },\n  isArray: (value: any) => {\n    return Array.isArray(value)\n  },\n}\n",
              ">": 1658430577247
            }
          }
        },
        "help.mts": {
          "": {
            ":": "import { chalk, fs } from 'zx'\nimport rainbowRoad from './rainbowRoad.mjs'\n\nlet { version } = await fs.readJson('./package.json')\nexport default (which: 'chainlocker' | 'store' | 'all' = 'all') => {\n  console.log(`${''}${rainbowRoad()}`)\n  //@ts-ignore\n  console.log(`${''}${chalk.cyanBright.bold.underline('❱❱ ChainLocker ❱❱')} ${chalk.yellowBright.underline(' Alpha' + ` v${version} ❱❱`)}`)\n  console.log(`${''}${chalk.white('Distributed and Encrypted P2P Graph Database Protocol. ')}\\n`)\n  console.log(`${''}${rainbowRoad()}`)\n  // if (which == ('chainlocker' || 'all')) {\n  //   console.log(\n  //     `${chalk.cyan.bold('                  ')}${chalk.white(\n  //       `chainlocker  [   vault   ]  current (${chalk.italic('shows current vault context')})   `\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.white(\n  //       `                            --new (${chalk.italic('create new vault context')})   `\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.red(\n  //       `IN DEV                        --delete (${chalk.italic('delete current vault context')})   `\n  //     )}\\n`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.white(\n  //       `             [   keys    ]  --show (${chalk.italic('shows the keypair to current vault context')}) `\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.white(\n  //       `                            --generate (${chalk.italic('generate and name new keypair to store in current vault context')})   `\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                 ')}${chalk.red(\n  //       `IN DEV                        --env (${chalk.italic('set keypair as environment variable')})   `\n  //     )}`\n  //   )\n  // }\n  // //TODO: PEER,  RELAY\n  // if (which == ('store' || 'all')) {\n  //   console.log(`\\n${chalk.cyan.bold('❱❱ DATABASE  ❱❱   ')}\\n`)\n  //   console.log(\n  //     `${chalk.blueBright('❱❱ Get Data  ❱❱  ')}${chalk.white(\n  //       '<--path/to/node/record-->  [   get   ]   --exec <node || shell || env || docker(IN DEV)> '\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                ')}${chalk.white(\n  //       '                                         --write-file <absolute local file path> '\n  //     )}`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                ')}${chalk.white(\n  //       '                                         --write-file <absolute local file path> '\n  //     )}\\n`\n  //   )\n\n  //   console.log(\n  //     `${chalk.cyan.bold('❱❱ Put Data  ❱❱   ')}${chalk.white(\n  //       '<--path/to/node/record-->  [   put   ]   --file <absolute local file path> '\n  //     )}\\n`\n  //   )\n  //   console.log(\n  //     `${chalk.blueBright('                ')}${chalk.white('                                         --url <domain or ip addr> ')}`\n  //   )\n  //   console.log(`${chalk.blueBright('                ')}${chalk.white('                                         --string <stdin> ')}`)\n  // }\n  console.log(`\\n${''}${chalk.white('Chainlocker is superpowered by GUN. https://gun.eco ')}`)\n  console.log(`${''}${rainbowRoad()}`)\n  console.log(`${''}${rainbowRoad()}`)\n  console.log(`${''}${rainbowRoad()}`)\n}\n",
            ">": 1658430577247.011
          }
        },
        "src": { "": { ":": { "#": "bresnow/cli/src" }, ">": 1658429297887.003 } }
      },
      "/": {
        "lib\u001b": {
          "scope.mts": {
            "": {
              ":": "import Gun, { IGunInstance } from 'gun'\nimport 'gun/lib/path.js'\nimport chokidar from 'chokidar'\nimport fs from 'fs'\nimport { glob, chalk } from 'zx'\nimport fsUtil, { read, write, exists } from '../file-utils.mjs'\nimport os from 'os'\n\n/**\n * Scope watches the files in a directory and stores them in rad. No separate .ignore files as it uses the .gitignore file already in your current directory.\n * @param {string[]}what Glob pattern to watch\n * @param {callback(event, path, stats):void}callback Callback function to fire when a file or directory is added, changed, or removed\n * A fork of the HUB library... https://gun.eco/docs/hub.js#options\n * TODO: Broadcast files via relay server\n * TODO: ChainLocker\n */\nlet { username } = os.userInfo()\nGun.chain.scope = async function (what, callback, { verbose , alias  }) {\n  let _gun = this\n  verbose = verbose ?? true\n  alias = alias ?? username \n  let matches = await glob(what, { gitignore: true })\n\n  try {\n    let scope = chokidar.watch(matches, { persistent: true })\n    const log = console.log\n    scope.on('all', (event, path, stats) => {\n      let fileOpts = { path, matches, event }\n      if (callback) {\n        callback(path, event, matches)\n        if (verbose) {\n          log(chalk.green(`scope callback fired : ${event} ${path}`))\n        }\n      }\n    })\n    scope\n      .on('add', async function (path, stats) {\n        if (!exists(path)) {\n          verbose && log(chalk.red(`File ${path} does not exist`))\n          return\n        }\n        let nodepath = path.includes('/') ? path.split('/').map(x=> x.trim()) : [path]\n        let name = nodepath.length > 1 ? nodepath.at(nodepath.length - 1) : nodepath[0]\n        nodepath.pop() && nodepath.pop()\n        if (nodepath && name) {\n          _gun\n            .get(alias)\n            .path(nodepath)\n            .put({ [name]: await read(path) })\n          verbose && log(chalk.green(`File ${path} has been added`))\n        } else {\n          log(chalk.red(`Error adding file ${path}`))\n          return\n        }\n      })\n      .on('change', async function (path, stats) {\n        if (!exists(path)) {\n          verbose && log(chalk.red(`File ${path} does not exist`))\n          return\n        }\n        let nodepath = path.includes('/') ? path.split('/').map(x=> x.trim()) : [path.trim()]\n        let name = nodepath.length > 1 ? nodepath.at(nodepath.length - 1) : nodepath[0]\n        nodepath.pop() && nodepath.pop()\n        if (nodepath && name) {\n          _gun\n            .get(alias)\n            .path(nodepath)\n            .put({ [name]: await read(path) })\n          verbose && _gun\n            .get(alias)\n            .path(nodepath).once((d)=>{\n              log('PATH\\n'+chalk.green(d._['#']))\n            })\n          verbose && log(chalk.green(`File ${path} has been changed`))\n        } else {\n          log(chalk.red(`Error onChange for ${path}`))\n          return\n        }\n      })\n      .on('unlink', async function (path) {\n        if (!exists(path)) {\n          verbose && log(chalk.red(`File ${path} does not exist`))\n          return\n        }\n        let nodepath = path.includes('/') ? path.split('/').map(x=> x.trim()) : [path]\n        let name = nodepath.length > 1 ? nodepath.at(nodepath.length - 1) : nodepath[0]\n        nodepath.pop() && nodepath.pop()\n        if (nodepath && name) {\n          _gun\n            .get(alias)\n            .path([...nodepath, name])\n            .put(null as any)\n          verbose && log(chalk.green(`File ${path} has been removed`))\n        } else {\n          log(chalk.red(`Error deleting file ${path}`))\n          return\n        }\n      })\n    if (verbose) {\n      scope\n        ?.on('addDir', (path) => log(chalk.magenta(`Directory ${path} has been added`)))\n        .on('unlinkDir', (path) => log(chalk.magenta(`Directory ${path} has been removed`)))\n        .on('error', (error) => log(chalk.magenta(`Watcher error: ${error}`)))\n        .on('ready', () => log(chalk.magenta('Initial scan complete. Ready for changes')))\n    }\n  } catch (err) {\n    console.log(chalk.red('If you want to use the scope feature, you must install `chokidar` by typing `npm i chokidar` in your terminal.'))\n  }\n}\n",
              ">": 1658430577282
            }
          },
          "keys.mts": { "": { ":": "import Gun from 'gun'\nimport { SysUserPair } from '../auth.mjs'\n", ">": 1658430577247.01 } },
          "chainlocker.mts": {
            "": {
              ":": "import Gun, { GunSchema, IGunChain, IGunInstance, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\nimport { SysUserPair, MASTER_KEYS, MASTER_SERIAL } from '../auth.mjs'\nimport lz from '../lz-encrypt.mjs'\nimport lzString from 'lz-string'\nimport { lzObject } from 'lz-object'\nimport { exists, interpretPath, read } from '../file-utils.mjs'\nimport { warn } from '../debug.mjs'\nimport 'gun/lib/path.js'\nimport 'gun/lib/load.js'\nimport 'gun/lib/open.js'\nimport 'gun/lib/then.js'\nimport config from '../../../config/index.mjs'\nimport { getCID } from '../../src/index.mjs'\nconst SEA = Gun.SEA\n\n//TODO: FIX UINT8Array decompression\n\nGun.chain.vault = function (vault, cback, opts) {\n  let _gun = this\n  let gun = _gun.user()\n  let keys = opts?.keys ?? MASTER_KEYS // can use the master key made from the machine serial or bring your own keys\n  gun = gun.auth(keys, (ack) => {\n    let err = (ack as any).err\n    if (err) {\n      throw new Error(err)\n    }\n    let lock = gun.get(`ChainLocker`)\n    lock.once(async function (data) {\n      let cID = await getCID(vault, keys)\n\n      if (!data) {\n        let _data = { vault, vault_id: cID, config: { rad_directory: config.radDir } }\n        // vault data for when peered with another locker or Gun graph\n        let encrypted = await lz.encrypt(_data, keys, { encoding: opts?.encoding ?? 'utf16' })\n        lock.put(encrypted, (ak: any) => {\n          if (ak.err) {\n            throw new Error(ak.err)\n          }\n        })\n      }\n      if (data) {\n        let obj, tmp\n        tmp = data._\n        delete data._\n        obj = await lz.decrypt(data, keys, { encoding: opts?.encoding ?? 'utf16' })\n        if (obj.vault && obj.vault_id !== cID) {\n          //check POW hashes to make sure they match\n          throw new Error(`Err authenticating ${vault}`)\n        }\n        cback && cback({ _: tmp, chainlocker: obj, gun: ack })\n      }\n    })\n  })\n\n  _gun.keys = async function (secret) {\n    // can add secret string, username and password, or an array of secret strings\\\n    let keypair = MASTER_KEYS\n    if (secret) {\n      let sys = await SysUserPair(typeof secret === 'string' ? [secret] : [...secret])\n      keypair = sys.keys\n    }\n    return keypair\n  }\n  _gun.locker = (nodepath) => {\n    let path,\n      temp = gun as unknown as IGunChain<any> // gets tricky with types but doable\n    if (typeof nodepath === 'string') {\n      path = nodepath.split('/' || '.')\n      if (1 === path.length) {\n        temp = temp.get(nodepath)\n      }\n      nodepath = path\n    }\n    if (nodepath instanceof Array) {\n      if (nodepath.length > 1) {\n        var i = 0,\n          l = nodepath.length\n        for (i; i < l; i++) {\n          temp = temp.get(nodepath[i])\n        }\n      } else {\n        temp = temp.get(nodepath[0])\n      }\n    }\n    let node = temp\n    return {\n      async put(data, cb2) {\n        data = await lz.encrypt(data, keys, { encoding: opts?.encoding ?? 'utf16' })\n        node.put(data, (ack) => {\n          if (cb2) {\n            cb2(ack)\n          }\n        })\n      },\n      async value(cb) {\n        node.once(async (data) => {\n          let obj, tmp\n          if (!data) {\n            return cb({ err: 'Record not found' })\n          } else {\n            tmp = data._\n            delete data._\n            obj = await lz.decrypt(data, keys, { encoding: opts?.encoding ?? 'utf16' })\n            cb({ _: tmp, ...obj })\n          }\n        })\n      },\n    }\n  }\n\n  return gun //return gun user instance\n}\n",
              ">": 1658430577247.009
            }
          },
          "build.mts": {
            "": {
              ":": "#!/usr/bin/env node\nimport { glob } from 'zx'\nimport 'zx/globals'\nimport esbuild from 'esbuild'\nexport default async function () {\n  let matches = await glob(['**/*.mts', 'cli/**/*.mjs'], { gitignore: true })\n  matches.forEach((file) => {\n    console.log(file)\n    esbuild.build({\n      entryPoints: [file],\n      outfile: `bin/${file.replace('ts', 'js')}`,\n      bundle: false,\n      platform: 'node',\n    })\n  })\n}\n",
              ">": 1658430577258
            }
          },
          "p": {
            "air.mts": {
              "": {
                ":": "let crypto = await import('crypto').then((WebCrypto) => {\n  return WebCrypto.webcrypto\n})\nimport forge from 'node-forge'\nimport EC from 'elliptic'\nimport btoa from 'btoa'\nimport { ISEAPair } from 'gun'\nconst ec = EC.ec\nexport interface IPair {\n  (pwd: any, salt: string | any[]): Promise<ISEAPair>\n}\nexport default async function Pair(pwd: any, salt: string | any[]): ReturnType<IPair> {\n  // forge.options.usePureJavaScript = true\n  return new Promise((resolve, reject) => {\n    let ec_p256 = new ec('p256')\n\n    if (!pwd) pwd = forge.random.getBytesSync(32)\n\n    let privateKey_d = forge.md.sha256.create().update('d').update(pwd) as any //decrypt key\n    let privateKey_s = forge.md.sha256.create().update('s').update(pwd) as any //sign key\n\n    if (salt) {\n      if (salt instanceof String) salt = [salt]\n\n      for (let i = 0; i < salt.length; i++) {\n        privateKey_s = privateKey_s.update(salt[i])\n        privateKey_d = privateKey_d.update(salt[i])\n      }\n    }\n\n    privateKey_s = privateKey_s.digest().toHex()\n    privateKey_d = privateKey_d.digest().toHex()\n\n    let keyA_d = ec_p256.keyFromPrivate(privateKey_d, 'hex')\n    let validation = keyA_d.validate()\n    if (validation.reason) return reject(validation.reason)\n\n    let keyA_s = ec_p256.keyFromPrivate(privateKey_s, 'hex')\n    validation = keyA_s.validate()\n    if (validation.reason) return reject(validation.reason)\n\n    resolve({\n      pub: keyBuffer_to_jwk('ECDSA', Buffer.from(keyA_s.getPublic('hex'), 'hex')) as string,\n      priv: arrayBufToBase64UrlEncode(Buffer.from(privateKey_s, 'hex')),\n      epub: keyBuffer_to_jwk('ECDH', Buffer.from(keyA_d.getPublic('hex'), 'hex')) as string,\n      epriv: arrayBufToBase64UrlEncode(Buffer.from(privateKey_d, 'hex')),\n      // secret: arrayBufToBase64UrlEncode(Buffer.from(keyA_d.derive(keyA_s.getPublic()).toString('hex'), 'hex'))\n    })\n  })\n\n  function arrayBufToBase64UrlEncode(buf: Iterable<number>) {\n    let binary = ''\n    let bytes = new Uint8Array(buf)\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i])\n    }\n    return btoa(binary).replace(/\\//g, '_').replace(/=/g, '').replace(/\\+/g, '-')\n  }\n\n  function keyBuffer_to_jwk(type: string, raw_publicKeyRawBuffer: Buffer) {\n    let key\n    switch (type) {\n      case 'ECDSA':\n      case 'ECDH':\n        if (raw_publicKeyRawBuffer[0] == 4)\n          key =\n            arrayBufToBase64UrlEncode(raw_publicKeyRawBuffer.slice(1, 33)) +\n            '.' +\n            arrayBufToBase64UrlEncode(raw_publicKeyRawBuffer.slice(33, 66))\n        break\n      default:\n        key = false\n        break\n    }\n    return key\n  }\n  //Hey dan whats this?\n  function b32(s: string) {\n    let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n\n    let parts = []\n    let quanta = Math.floor(s.length / 5)\n    let leftover = s.length % 5\n\n    if (leftover != 0) {\n      for (let i = 0; i < 5 - leftover; i++) {\n        s += '\\x00'\n      }\n      quanta += 1\n    }\n\n    for (let i = 0; i < quanta; i++) {\n      parts.push(alphabet.charAt(s.charCodeAt(i * 5) >> 3))\n      parts.push(alphabet.charAt(((s.charCodeAt(i * 5) & 0x07) << 2) | (s.charCodeAt(i * 5 + 1) >> 6)))\n      parts.push(alphabet.charAt((s.charCodeAt(i * 5 + 1) & 0x3f) >> 1))\n      parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 1) & 0x01) << 4) | (s.charCodeAt(i * 5 + 2) >> 4)))\n      parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 2) & 0x0f) << 1) | (s.charCodeAt(i * 5 + 3) >> 7)))\n      parts.push(alphabet.charAt((s.charCodeAt(i * 5 + 3) & 0x7f) >> 2))\n      parts.push(alphabet.charAt(((s.charCodeAt(i * 5 + 3) & 0x03) << 3) | (s.charCodeAt(i * 5 + 4) >> 5)))\n      parts.push(alphabet.charAt(s.charCodeAt(i * 5 + 4) & 0x1f))\n    }\n\n    let replace = 0\n    if (leftover == 1) replace = 6\n    else if (leftover == 2) replace = 4\n    else if (leftover == 3) replace = 3\n    else if (leftover == 4) replace = 1\n\n    for (let i = 0; i < replace; i++) parts.pop()\n    for (let i = 0; i < replace; i++) parts.push('=')\n\n    return parts.join('')\n  }\n}\n",
                ">": 1658430577247.014
              }
            },
            "ush.mts": {
              "": {
                ":": "#!/usr/bin/env node\nimport { $, question, YAML, chalk } from 'zx'\nimport { io } from 'fsxx'\nimport 'zx/globals'\nexport default async function () {\n  $.verbose = false\n  let pkg = (await io.json`package.json`) as any\n  let message,\n    version = (pkg as any).version\n\n  // Version prompt ... (if not provided current version is used)\n  if (version === undefined) {\n    version = await question(`${chalk.green('Version? \\n Current Version ') + chalk.cyan(pkg.data.version)}: `)\n    version === '' ? (version = pkg.data.version) : (version = version.trim())\n  }\n  //PACKAGE>JSON MODIFY VERSION\n  pkg.data.version = version\n  await pkg.save()\n\n  //Commit Message (if not provided default message is used)\n  if (message === undefined) {\n    message = await question(chalk.green('Message for commit : '))\n    if (message === '' || message.length < 2) {\n      message = `Default Commit ${new Date(Date.now()).toLocaleString('en-US', { timeZone: 'America/New_York' }).slice(0, -3)}`\n    }\n  }\n\n  // Prettier and finalize\n\n  await $`git status`\n  try {\n    await $`yarn prettier`\n  } catch (error) {\n    console.log(chalk.red(error))\n  }\n  await $`git add --all`\n  await $`git commit -s -m ${`${message} | ${version}`}`\n  await $`git push`\n}\n",
                ">": 1658430577259.003
              }
            }
          }
        },
        "src\u001b": {
          "map-case.mts": {
            "": {
              ":": "import Help from '../../lib/help.mjs'\n// import '../lib/chain-hooks/chainlocker.mjs'\nimport Push from '../../lib/dev/push.mjs'\nimport Build from '../../lib/dev/build.mjs'\nimport Vault from './vault.mjs'\nimport Store from './store.mjs'\nimport { IGunInstance } from 'gun'\nimport { err } from '../../lib/debug.mjs'\nexport default (vault: string, gun: IGunInstance) =>\n  new Map([\n    [\n      'help',\n      async function (_args: string[] = []) {\n        //TODO: finish help\n        Help('chainlocker')\n      },\n    ],\n    [\n      'vault',\n      async function (args: string[] = []) {\n        await Vault(args, vault, gun)\n      },\n    ],\n    [\n      'store',\n      async function (args: string[] = []) {\n        await Store(args, vault, gun)\n      },\n    ],\n    // DEVELOPER COMMANDS\n    [\n      'dev',\n      async function (args: string[] = []) {\n        let [key, value, ...flags] = args\n        if (key === 'push') {\n          console.log(chalk.white.italic(`Pushing to github...`))\n          try {\n            await Build()\n            await Push()\n          } catch (error) {\n            err(error as string)\n          }\n        }\n        if (key === 'build') {\n          console.log(chalk.white.italic(`Building...`))\n          await Build()\n        }\n      },\n    ],\n  ])\n",
              ">": 1658429297887.002
            }
          },
          "vault.mts": {
            "": {
              ":": "import { chalk, $, fetch, glob, question } from 'zx'\nimport Help from '../../lib/help.mjs'\nimport config from '../../../config/index.mjs'\nimport { readDirectorySync } from '../../lib/file-utils.mjs'\nimport { remove } from '../../lib/file-utils.mjs'\nimport { warn } from '../../lib/debug.mjs'\nimport { IGunChain, IGunInstance } from 'gun'\nexport default async function (args: string[] = [], currentVault: string, gun: IGunChain<any> | IGunInstance<any>) {\n  let [key, value, ...flags] = args\n  //   console.log([key, value, ...flags], 'key value flags')\n  switch (key) {\n    case 'create':\n      let newVault = value\n      newVault = newVault.trim()\n      console.log(chalk.italic.white(`Checking out from ${currentVault} to ${newVault}\\n ❱ `))\n      break\n    case 'list':\n      let vdir = readDirectorySync(config.radDir)\n      console.log(vdir)\n      vdir.forEach(async (v) => {\n        if (!v) {\n          warn(\"No vaults found. Try the 'chainlocker create' command to create a new vault.\")\n        }\n        let [parent, goods] = v.split(config.radDir)\n        console.log(chalk.italic.blueBright(goods))\n      })\n      break\n    case 'delete':\n      //@ts-ignore\n      var peers = gun.back('opt.peers')\n      console.log('PEERS', peers)\n      //@ts-ignore\n      var mesh = gun.back('opt.mesh')\n      Object.values(peers).forEach(async (peer) => {\n        console.log(chalk.italic.white(`${peer}`))\n      })\n\n      console.log(`\\n`)\n      console.log(\n        chalk.bold.white(\n          `${currentVault} is connected to the peers listed above. You will be able to delete this vault locally but the encrypted data will remain on the network.`\n        )\n      )\n      let confirm = await question(\n        chalk.yellowBright.bold(`Please Input ${chalk.green.bold(currentVault.toUpperCase())} To Veryify This Choice.\\n`)\n      )\n      if (confirm.trim() === currentVault.toUpperCase()) {\n        console.log(chalk.italic.white(`Deleting ${currentVault}`))\n        await remove(config.radDir + currentVault)\n      } else {\n        warn('Aborting vault deletion.')\n      }\n\n      break\n    default:\n      Help()\n      break\n  }\n}\n",
              ">": 1658429297887.003
            }
          }
        }
      }
    }
  },
  "l5v": {
    "c": {
      "lp0": {
        "k01a25VFX7sEA0SG\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658426976740
          }
        },
        "l01aP09g1jphIp7a\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658426976741 } },
        "n0e9VWl63qTjTRx8\u001bindex.mts": {
          "": {
            ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
            ">": 1658426976743.01
          }
        }
      },
      "ng2": {
        "y01aEHDG2KnGJxk9\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658427058474
          }
        },
        "z0": {
          "1aTxOahOdyiL7m\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658427058475 } },
          "6ncNpzKiyMloUj\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658427058475.004
            }
          }
        }
      }
    },
    "d": {
      "bb7": {
        "h01a5RhbCFhQftqy\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658428171901
          }
        },
        "i01aSPvRq5vSGLW3\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658428171902 } },
        "j03tfh4rRS6KHjlu\u001bindex.mts": {
          "": {
            ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
            ">": 1658428171903.002
          }
        }
      },
      "g3m": {
        "40": {
          "1a4hAXTefoc031\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658428395340 } },
          "5cn9stz7ort6B\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658428395340.003
            }
          }
        },
        "301axx6Lvb5H9FKF\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658428395339
          }
        }
      },
      "h": {
        "azz0": {
          "1aJ7rpF5l9iCUy\u001btypes.mts": {
            "": {
              ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
              ">": 1658428451567
            }
          },
          "3thrmG5AIbqKPn\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658428451567.002 } }
        },
        "b0101aFUm3PvkKooq6\u001bindex.mts": {
          "": {
            ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
            ">": 1658428451569
          }
        }
      },
      "j2se0": {
        "1aOHChIRrWZ8Ce\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658428534238
          }
        },
        "50pFAInpejdCO\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658428534238.003 } },
        "agAb2Esk8T5IwH\u001bindex.mts": {
          "": {
            ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
            ">": 1658428534238.007
          }
        }
      },
      "ssf": {
        "w0": {
          "1aekRBFJVVdMh9\u001btypes.mts": {
            "": {
              ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
              ">": 1658428987388
            }
          },
          "3tjKHnPoylksTI\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658428987388.002 } }
        },
        "x01arStmffkOhqf6\u001bindex.mts": {
          "": {
            ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
            ">": 1658428987389
          }
        }
      },
      "yc5": {
        "g01ad9SNXWz7sfyi\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658429246212
          }
        },
        "h01aGuXZMT1kPvfl\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658429246213 } },
        "j05chbRjJUod3K6\u001bindex.mts": {
          "": {
            ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
            ">": 1658429246215.003
          }
        }
      },
      "zg0": {
        "t0": {
          "1aElppBcJ76FFV\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658429297885 } },
          "5KeLNoybcAUtA\u001btypes.mts": {
            "": {
              ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
              ">": 1658429297885.003
            }
          }
        },
        "u01a4R67XvQXXCAV\u001bindex.mts": {
          "": {
            ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
            ">": 1658429297886
          }
        }
      }
    },
    "e": {
      "5bw": {
        "a": {
          "Uuzirih5O2r1\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658429572473 } },
          "02j0EPFFX1i3oGN\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658429572474.001
            }
          }
        },
        "b01aMnzTbU1tUPVU\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658429572475
          }
        }
      },
      "6q3": {
        "h01a1x3hHpS24os6\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658429637533 } },
        "i0": {
          "1aTiXpbtCubNWw\u001btypes.mts": {
            "": {
              ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
              ">": 1658429637534
            }
          },
          "5qsFfKHOFOuoQ\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658429637534.003
            }
          }
        }
      },
      "ex4": {
        "8": {
          "03tZSpRnPjqCkgA\u001btypes.mts": {
            "": {
              ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
              ">": 1658430019880.002
            }
          },
          "1ddsjgEEw7k9A81\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658430019880.037
            }
          }
        },
        "701aLtsWHuSrZZ7C\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658430019879 } }
      },
      "g00": {
        "10": {
          "1aH488b8BJACNv\u001btypes.mts": {
            "": {
              ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
              ">": 1658430070273
            }
          },
          "3txR7kLwDfT9nV\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658430070273.002 } },
          "6nUqEKoFLJFBSR\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658430070273.004
            }
          }
        },
        "20": {
          "gsZHevGpWePE1J\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658430070274.012 } },
          "jmPP495dAQ99Oj\u001btypes.mts": {
            "": {
              ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
              ">": 1658430070274.014
            }
          },
          "mXplAeXP16LEv\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658430070274.016
            }
          }
        }
      },
      "h23": {
        "6": {
          "D9LKo5lsiApy\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658430119633.001 } },
          "05pto7No2lmAVe\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658430119634.003
            }
          }
        },
        "805wQTF4gZaJGcU\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658430119636.003
          }
        }
      },
      "jq": {
        "kz0": {
          "1ai4AfUqeZIfaF\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658430244691 } },
          "3tMNJqoAeRhZF1\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658430244691.002
            }
          }
        },
        "l001asf2B9I92obVt\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658430244692
          }
        }
      },
      "lql": {
        "d0": {
          "1aJt1OJkuMnF68\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658430338017 } },
          "6niGEJWPAywACl\u001bindex.mts": {
            "": {
              ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
              ">": 1658430338017.004
            }
          }
        },
        "f096ZRL5uxvLw904\u001btypes.mts": {
          "": {
            ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
            ">": 1658430338019.006
          }
        }
      },
      "qv6": {
        "m0": {
          "1aRQ6tCQOZLRKX\u001bindex.mts": { "": { ":": "import './cli/src/index.mjs'\n", ">": 1658430577246 } },
          "870A1RBSJ7qS1\u001btypes.mts": {
            "": {
              ":": "import { FSWatcher } from 'chokidar';\nimport { Stats } from 'fs'\nimport { IGunChain, IGunInstanceRoot, IGunUserInstance, ISEAPair } from 'gun'\n\ndeclare module 'gun/types' {\n  export interface IGunInstance<TNode> extends IGunUserInstance<TNode> {\n    /**\n     * Create a new vault context.\n     *\n     * Takes the lockername and generates the keys against machine info.\n     * Should require sudo privilages to create a new vault.\n     *\n     */\n    vault(vaultname: string, cb?: CallBack, options?: VaultOpts): IGunUserInstance<any, any, any, IGunInstanceRoot<any, IGunInstance<any>>>\n    /**\n     * Get a locker instance for a node in the chain.\n     *\n     * @param {string}\n     */\n    locker(nodepath: string | string[]): { value(cb: CallBack): Promise<void>; put(data: any, cb?: CallBack): Promise<void> }\n    keys(secret?: string | string[]): Promise<ISEAPair>\n  }\n\n  export interface IGunChain<TNode> extends IGunInstance {\n    scope(\n      what: string[],\n      callback: ScopeCb | undefined,\n opts: {\n        verbose: boolean\n        alias: string\n      }\n    ): Promise<void>\n  }\n}\nexport type ScopeCb = (\n  path?: string, event?: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', matches?: string[]) => void\nexport type CallBack = (...ack: any) => void\n\nexport type VaultOpts = { keys?: ISEAPair; encoding?: 'utf16' | 'base64' | 'uint8array' | 'uri' }\n",
              ">": 1658430577246.0051
            }
          }
        },
        "n0gsO3sGyTlOAync\u001bindex.mts": {
          "": {
            ":": "import { ISEAPair } from 'gun'\n\nexport default {\n  radDir: process.env.LOCKER_DIRECTORY || '.chainlocker',\n  defaultVault: process.env.LOCKER_NAME || 'default',\n  defaultRootNode: process.env.DEFAULT_ROOT_NODE ?? 'root',\n}\n",
            ">": 1658430577247.012
          }
        }
      }
    }
  },
  "~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo": {
    "\u001bpath": {
      "": {
        ":": "{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path\"},\"~\":\"Sz9pwUfsrO0mtR9E8Q0paz/B1DHlzgd2uDsUzzXobPCMJViu9X3jEIVhuNfBHCZs7lN7BseHIwCz/4NH2oeAAg==\"}",
        ">": 1658430377292
      }
    },
    "/path": {
      "\u001bto": {
        "": {
          ":": "{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to\"},\"~\":\"QG7WGHmwiAqmKLLVgVtMLaGQ+TngieKBIFVcavioAyj+Y8wodZQRylVg/qPHNM6Ea/D5dbOvrTE3NNYTyirt+g==\"}",
          ">": 1658430377292
        }
      },
      "/to": {
        "\u001b": {
          "node": {
            "": {
              ":": "{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to/node\"},\"~\":\"jVynw/TTnFqL05U1AHq5YwL49tXjANJ9+G7h/KbpjjxUoSv+ANyuWPIe8sn8GhQDiwEW+jxrnUTpeKOnlBVyAA==\"}",
              ">": 1658430156430
            }
          },
          "my": {
            "": {
              ":": "{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to/my\"},\"~\":\"K+L9xuEbLpSAFQC0lq0o7kN5sbLmifIqfP3US90+agOR7QKAtbJ25ig5WdCq8JytjOPVKX+lWkiCI51FrrYYSA==\"}",
              ">": 1658430377292
            }
          }
        },
        "/": {
          "node\u001bdata": {
            "": {
              ":": "{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ഀ̡刧㠾䂋ìƄݐ࣠ᡬ䁶ŘƸ̔〱䂛ވ˶:䞠⎠ፓ༲繂ǴL‡崐ȸ¸ˑ䠥熊䀣⊠ঀ咪Ạʵޚ.晀äŜ侸Ψ拱䈀஀˯⟵⊸XĒܼᬠᶣ䀥᠀Ëâ倠彀  \",\"~\":\"LEaqt82lJKSeyWIgtrMfFadiOAjgO1I8TM8VwlCbJesxEeM5NSVTyPo/Q/+iXACRcIO6qNf7WzT6htIdEwnWfg==\"}",
              ">": 1658430156430
            }
          },
          "my": {
            "\u001bdata": {
              "": {
                ":": "{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to/my/data\"},\"~\":\"4iWoUYntAK1fp9E91Z12TLpMAKTPsxU3NhmHhyOD/pHtNAnamcG1WVj/CPanjcw3/WHutJY++BG/VM3HKaCyyw==\"}",
                ">": 1658430377292
              }
            },
            "/data": {
              "\u001b": {
                "v2": {
                  "": {
                    ":": "{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ༀ඼⁇ୀ᛫>〠〬捠㬠㕌Ψ&䁷*ìi嚀⌠ᢠហ⊠ጠᗐWv+mkࠠ橐㦲ఢ唐䎔䠧ဢᅀୀчⱄƠ⦩VGEcఠ幈-ਥ⍄䊥᧨Ŝ処.ㆠᡠʉဧ倣喔刀ᆆ*䡊,眭㫘Ȍ䩱ٚᒁػ沅%礠 \",\"~\":\"R4jKcsNP0eZXybB8np5w9ElN/W4J8ZQTjH4TCdZfoIK7NKsOMiyRRjFdZiLWTAvzWzSqkaLyirn4QxvRa6Psrg==\"}",
                    ">": 1658430280142
                  }
                },
                "node": {
                  "": {
                    ":": "{\":\":{\"#\":\"~04CKY9Yqwx9qmfLQetWkvWC21oChuhaXNVDyTYQVzlk.-5sA6JJPMhbA3qV-4VR5Fa9fJuQG8BXBi_tM0J-ieIo/path/to/my/data/node\"},\"~\":\"0Pm1/Qh6+OZLPLlU2qMtL5Ggm3W8zENsfsFeBr9jKVTLuoQ3KtQH7N1gH78ut7UXPHPy4rCwbn4HessDHZ1yjg==\"}",
                    ">": 1658430377292
                  }
                }
              },
              "/node\u001bvalue": {
                "": {
                  ":": "{\":\":\"ᥢ䑀䇜Ѡ挡㥠⹈ເܡ並倩䂖LTÈ΀Å䁯Æd˸ڱ䚠⤠渡త⠪兌ޠ௸=䁛传̦;ᙦbnᰠ更Řń瀡䖸θϸ˨新֔堯ℴ㷻䙸c㦠╶Ü⠠ഴ2槤䊠è䦌öᤠᗎ伸஀ҁ掘ļ䓆匠㢠Ǡ䐵à䙺淬楹㈠޺᛽䯬加̙  \",\"~\":\"Z1S2uhyqVTdx+L7jlQd8olH3VnCEYU5PwgoB5xptdqD6VMiTAZyh2cIcokZQqU2ohiT3RHhmARudBp8yy5BtTA==\"}",
                  ">": 1658430377292
                }
              }
            }
          }
        }
      }
    }
  }
}
